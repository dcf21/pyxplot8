% PROGRAMMING.TEX
%
% The documentation in this file is part of PyXPlot
% <http://www.pyxplot.org.uk>
%
% Copyright (C) 2006-2010 Dominic Ford <coders@pyxplot.org.uk>
%               2009-2010 Ross Church
%
% $Id$
%
% PyXPlot is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% You should have received a copy of the GNU General Public License along with
% PyXPlot; if not, write to the Free Software Foundation, Inc., 51 Franklin
% Street, Fifth Floor, Boston, MA  02110-1301, USA

% ----------------------------------------------------------------------------

% LaTeX source for the PyXPlot Users' Guide

\chapter{Programming and Flow Control}

In this chapter we turn to the loop constructs which are available in PyXPlot,
which are principally useful for automatically executing a common set of
commands many times on many different \datafile s. We also discuss string
variables, explain how to execute shell commands from within PyXPlot, and
introduce a simple framework for automatically re-executing PyXPlot scripts
whenever they change, to allow plots to update automatically whenever the
scripts used to produce them are modified.

\section{Conditionals}

The \indcmdt{if} can be used to conditionally execute a series of commands only
if a certain criterion is satisfied. In its simplest form, its syntax is

\begin{verbatim}
if <expression> {
  ....
 }
\end{verbatim}

\noindent where, as in C, the algebraic expression is deemed to be true if it
evaluates to any non-zero value, and to be false if it is exactly zero. The
list of commands to be executed must begin on a new line after the {\tt if}
statement, and the closing brace must be on a line by itself; alternatively,
semi-colons may, as always, be used in place of new lines. The opening brace
need not necessarily be on the same line as the {\tt if} statement, as is
demonstrated in the following example:

\begin{verbatim}
if (x==0)
 {
  print "x is zero"
 } else if (x>0) {
  print "x is positive"
 } else {
  print "x is negative"
 }
\end{verbatim}

In this example, the first script block, contained between the first pair of
braces, is executed if the first conditional, {\tt x==0}, is true. If the first
script block is not executed, PyXPlot proceeds to test the second conditional,
following the {\tt else if} statement, and executes the second script block if
this is true. The final script block is executed if all of the preceeding
conditionals have tested false. Any number of {\tt else if} statements can be
chained after one another, and a final {\tt else} statement can always be
optionally supplied. The {\tt else} and {\tt else if} statements must always be
placed on the same line as the closing brace of the preceeding script block.

The precise way in which a string of {\tt else if} statements are arranged in a
PyXPlot script is a matter of taste: the following is a more compact but
equivalent version of the example given above:

\begin{verbatim}
if      (x==0) { ; print "x is zero"     ; } \
else if (x> 0) { ; print "x is positive" ; } \
else           { ; print "x is negative" ; }
\end{verbatim}

\section{For Loops}

As in most programming languages, {\tt for} loops are used to execute a series
of lines several times. PyXPlot's \indcmdt{for} command is most similar to that
of the BASIC programming language, and has the syntax

\begin{verbatim}
for <variable> = <start> to <end> {step <step>}
 {
  ....
 }
\end{verbatim}

\noindent For example, the following script would run the supplied script block
repeatedly with different values of the variable {\tt x}, starting at zero,
increasing by two each time, and stopping once {\tt x} reaches ten. Thus, the
numbers 0, 2, 4, 6 and 8 would be printed:

\begin{verbatim}
for x = 0 to 10 step 2
 {
  print x
 }
\end{verbatim}

If no step size is supplied, then a unit step size is adopted. If a negative
step size is indicated, then the starting value of the loop variable must be
greater than the end value, otherwise an error is returned, since the loop
would otherwise run indefinitely. Likewise, if a step size of zero is
specified, an error is returned.

The same rules concerning the placement of brace characters apply to the
\indcmdt{for} command as to the {\tt if} command.

\section{Foreach Loops}

The \indcmdt{foreach} command may be used to run a script block once for every
file in the current working directory which matches one or more supplied file
wildcards.  For example,

\begin{verbatim}
foreach x in "*.dat" "*.txt"
 {
  print x
 }
\end{verbatim}

\noindent would run the supplied script block once for every file in the
current working directory with a {\tt .dat} or a {\tt .txt} suffix. The effect
would be rather similar to typing

\begin{verbatim}
!ls *.dat
\end{verbatim}

The quotes around each supplied search string are optional if and only if all
of the characters in that search string are alphanumeric. Since both of the
wildcard characters {\tt *} and {\tt ?} are non-alphanumeric, this exception
applies in practice only to unique explicit filenames in the present working
directory.  An error is returned if there are no files in the present directory
which match the supplied wildcard. The following example would produce a plot
of all of the \datafile s in the current directory:

\begin{verbatim}
plot
foreach x in "*.dat"
 {
  replot x using 1:2
 }
\end{verbatim}

Alternatively, the \indcmdt{foreach} command may be used to run a script block
once for every value of a variable in a supplied list, as in

\begin{verbatim}
foreach x in (-1,pi,10)
 {
  print x
 }
\end{verbatim}

\noindent would print out the numbers $-1$, $\pi$ and 10.

\section{Foreach Datum Loops}

\section{While and Do Loops}

The \indcmdt{while} command may be used to continue running a script block
until some stopping criterion is met. Two types of while loop are supported:

\begin{verbatim}
while <criterion>
 {
  ....
 }

do
 {
  ....
 } while <criterion>
\end{verbatim}
\indcmd{do}

The former example would execute the enclosed script block repeatedly, testing
the algebraic expression supplied to the \indcmdt{while} command immediately
before each repetition, and stopping if it tested false. The latter example is
very similar, but tests the supplied algebraic expression immediately {\it
after} each repetition. Thus, the former example may never actually execute the
supplied script block if the looping criterion tests false, but the latter
example is always guaranteed to run its script block at least once.

The following example would continue looping indefinitely until stopped by the
user:

\begin{verbatim}
while (1)
 {
  print "Hello, world!"
 }
\end{verbatim}

\example{ex:mandelbrot}{A script to produce an ASCII-art representation of the Mandelbrot Set}{
In this example, we use all of PyXPlot's loop constructs together in a script
which calculates the Mandelbrot Set and outputs an ASCII-art representation of
it to the terminal. Insert details about what the Mandelbrot Set is. The script is as follows: \vspace{0.5cm}\\

{\footnotesize\tt set numerics complex}\\
{\footnotesize\tt for~y=2~to~-2~step~-0.15}\\
{\footnotesize\tt ~\{}\\
{\footnotesize\tt ~~linebuffer~=~""}\\
{\footnotesize\tt ~~for~x=-2~to~2~step~0.075}\\
{\footnotesize\tt ~~~\{}\\
{\footnotesize\tt ~~~~zi~=~x+i*y;~z=zi;~iter=0;}\\
{\footnotesize\tt ~~~~while~(abs(z)<2)~and~(iter<21)}\\
{\footnotesize\tt ~~~~~\{}\\
{\footnotesize\tt ~~~~~~z~=~z**2~+~zi}\\
{\footnotesize\tt ~~~~~~iter=iter+1}\\
{\footnotesize\tt ~~~~~\}}\\
{\footnotesize\tt ~~~~if~~~~~~(iter~<~~1)~\{~;~linebuffer~="\%s~"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~~2)~\{~;~linebuffer~="\%s."\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~~4)~\{~;~linebuffer~="\%s-"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~20)~\{~;~linebuffer~="\%s*"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~~~~~~~~~~~~~~~~\{~;~linebuffer~="\%s\&"\%(linebuffer)~;~\}}\\
{\footnotesize\tt ~~~\}}\\
{\footnotesize\tt ~~print~linebuffer}\\
{\footnotesize\tt ~\}} \vspace{0.5cm}\\

The output of this script is as follows: \\

{\tt |~~~~~~~~~~~~~~~~~....................~~~~~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~............................~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~..................................~~~~~~~~~~}\newline
{\tt |~~~~~~~~......................................~~~~~~~~}\newline
{\tt |~~~~~~........-------------.....................~~~~~~}\newline
{\tt |~~~~~....--------------****-----.................~~~~~}\newline
{\tt |~~~~..----------------*******------................~~~}\newline
{\tt |~~~.---------------*****\&\&\&****------...............~~}\newline
{\tt |~~.-------------***\&***\&\&\&\&\&*****-----..............~~}\newline
{\tt |~.---------********\&\&\&\&\&\&\&\&\&\&\&\&\&**-----..............~}\newline
{\tt |~------**********\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&*------.............~}\newline
{\tt |~----******\&\&\&\&\&*\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&*------..............}\newline
{\tt |~********\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~---*****\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~-----*****\&\&\&\&\&*\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~-------***********\&\&\&\&\&\&\&\&\&\&\&\&\&**------.............~}\newline
{\tt |~~----------*******\&\&\&\&\&\&\&\&\&\&\&\&\&**-----..............~}\newline
{\tt |~~.--------------*******\&\&\&******-----..............~~}\newline
{\tt |~~~..---------------*****\&****------...............~~~}\newline
{\tt |~~~~...---------------******------................~~~~}\newline
{\tt |~~~~~.....---------------------..................~~~~~}\newline
{\tt |~~~~~~~..........-------.......................~~~~~~~}\newline
{\tt |~~~~~~~~~.....................................~~~~~~~~}\newline
{\tt |~~~~~~~~~~~................................~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~~..........................~~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~~~~~~~................~~~~~~~~~~~~~~~~~~~}\\
}

\section{Subroutines}

\section{String variables}
\label{sect:stringvars}

String variables can be assigned in a manner analogous to numeric variables,
using the $=$ command followed by a string enclosed in quotation marks. They can
then be used wherever a quoted string could be used, for example as a filename
or a plot title, as in:\index{variables!string}

\begin{verbatim}
plotname = "The Growth of a Rabbit Population"
set title plotname
\end{verbatim}

String variables can be modified using the search-and-replace string
operator\index{string operators!search and replace}\footnote{Programmers with
experience of {\tt perl} will recognise this syntax.}, =$\sim$\index{=$\sim$
operator}, which takes a regular expression with a syntax similar to that
expected by the shell command {\tt sed}\index{sed shell command@{\tt sed} shell
command} and applies it to the relevant string.\footnote{Regular expression
syntax is a massive subject, and is beyond the scope of this manual. The
official GNU documentation for the {\tt sed} command is heavy reading, but
there are many more accessible tutorials on the web.}\index{regular
expressions} For example:

\begin{verbatim}
twister="seven silver soda syphons"
twister =~ s/s/th/
print twister
\end{verbatim}

Note that only the {\tt s} (substitute) command of {\tt sed} is implemented in
PyXPlot. Any character can be used in place of the {\tt /} characters in the
above example, for example:

\begin{verbatim}
twister =~ s@s@th@
\end{verbatim}

\noindent Flags can be passed, as in {\tt sed} or {\tt perl}, for example:

\begin{verbatim}
twister =~ s@s@th@g
\end{verbatim}

\noindent Table~\ref{tab:re_flags} lists all of the regular expression flags
recognised by the =$\sim$ operator.

\begin{table}
\framebox[\textwidth]{\footnotesize
\begin{tabular}{p{5mm}p{10.5cm}}
{\tt g} & Replace {\it all} matches of the pattern; by default, only the first match is replaced. \\
{\tt i} & Perform case-insensitive matching, such that expressions like {\tt [A-Z]} will match lowercase letters, too. \\
{\tt l} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the current locale. \\
{\tt m} & When specified, the pattern character {\tt \^{}} matches the beginning of the string and the beginning of each line immediately following each newline. The pattern character {\tt \$} matches at the end of the string and the end of each line immediately preceding each newline. By default, {\tt \^{}} matches only the beginning of the string, and {\tt \$} only the end of the string and immediately before the newline, if present, at the end of the string. \\
{\tt s} & Make the {\tt .} special character match any character at all, including a newline; without this flag, {\tt .} will match anything except a newline. \\
{\tt u} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the Unicode character properties database. \\
{\tt x} & This flag allows the user to write regular expressions that look nicer. Whitespace within the pattern is ignored, except when in a character class or preceded by an unescaped backslash. When a line contains a {\tt \#}, neither in a character class or preceded by an unescaped backslash, all characters from the leftmost such {\tt \#} through to the end of the line are ignored. \\
\end{tabular}}
\caption{A list of the flags accepted by the =$\sim$ operator. Most are rarely used, but the {\tt g} flag is very useful.}
\label{tab:re_flags}
\end{table}

Strings may also be put together using the string substitution operator, {\tt
\%}\index{\% operator@{\tt \%} operator}, which works in a similar fashion to
the Python string substitution operator\index{string operators!substitution}. This
is described in detail in Section~\ref{sec:string_subs_op}.  For example, to
concatenate the two strings contained in variables {\tt a} and {\tt b} into
variable {\tt c} one would run:\index{string operators!concatenation}

\begin{verbatim}
c = "%s%s"%(a,b)
\end{verbatim}

One common practical application of these string operators is to label plots
with the title of the \datafile\ being plotted, as in:

\begin{verbatim}
filename="data_file.dat"
title="A plot of the data in {\tt %s}."%(filename)
title=~s/_/\_/g # Underscore is a reserved character in LaTeX
set title title
plot filename
\end{verbatim}
\section{The \indcmdt{exec}}

The \indcmdt{exec} can be used to execute PyXPlot commands contained within
string variables. For example:

\begin{verbatim}
terminal="eps"
exec "set terminal %s"%(terminal)
\end{verbatim}

It can also be used to write obfuscated PyXPlot scripts.

\section{Shell Commands}

Shell commands\index{shell commands!executing} may be executed directly from
within PyXPlot by prefixing them with an \indcmdts{!} character. The
remainder of the line is sent directly to the shell, for example:

\begin{verbatim}
!ls -l
\end{verbatim}

\noindent Semi-colons cannot be used to place further PyXPlot commands after a
shell command on the same line.

\begin{dontdo}
!ls -l ; set key top left
\end{dontdo}

It is also possible to substitute the output of a shell command into a PyXPlot
command. To do this, the shell command should be enclosed in back-quotes (`).
For example:\index{backquote character}\index{shell commands!substituting}

\begin{verbatim}
a=`ls -l *.ppl | wc -l`
print "The current directory contains %d PyXPlot scripts."%(a)
\end{verbatim}

It should be noted that back-quotes can only be used outside quotes. For
example:

\begin{dontdo}
set xlabel '`ls`'
\end{dontdo}

\noindent will not work. The best way to do this would be:

\begin{dodo}
set xlabel `echo "'" ; ls ; echo "'"`
\end{dodo}

Note that it is not possible to change the current working directory by sending
the {\tt cd} command to a shell, as this command would only change the working
directory of the shell in which the single command is executed:

\begin{dontdo}
!cd ..
\end{dontdo}

PyXPlot has its own \indcmdt{cd} for this purpose, as well as its own
\indcmdt{pwd}:

\begin{dodo}
cd ..
\end{dodo}

\section{Script Watching: pyxplot\_watch}

PyXPlot includes a simple tool for watching command script files and executing
them whenever they are modified. This may be useful when developing a command
script, if one wants to make small modifications to it and see the results in a
semi-live fashion. This tool is invoked by calling the {\tt
pyxplot\_watch}\index{pyxplot\_watch}\index{watching scripts} command from a
shell prompt. The command-line syntax of {\tt pyxplot\_watch} is similar to
that of PyXPlot itself, for example:

\begin{verbatim}
pyxplot_watch script.ppl
\end{verbatim}

\noindent would set {\tt pyxplot\_watch} to watch the command script file
{\tt script.ppl}. One difference, however, is that if multiple script files are
specified on the command line, they are watched and executed independently,
\textit{not} sequentially, as PyXPlot itself would do. Wildcard characters can
also be used to set {\tt pyxplot\_watch} to watch multiple
files.\footnote{Note that {\tt pyxplot\_watch *.script} and
{\tt pyxplot\_watch $\backslash$*.script} will behave differently in most
UNIX shells.  In the first case, the wildcard is expanded by your shell, and a
list of files passed to {\tt pyxplot\_watch}. Any files matching the
wildcard, created after running {\tt pyxplot\_watch}, will not be picked up.
In the latter case, the wildcard is expanded by {\tt pyxplot\_watch} itself,
which {\it will} pick up any newly created files.}

This is especially useful when combined with \ghostview's\index{Ghostview}
watch facility. For example, suppose that a script {\tt foo.ppl} produces
postscript output {\tt foo.ps}. The following two commands could be used to
give a live view of the result of executing this script:

\begin{verbatim}
gv --watch foo.ps &
pyxplot_watch foo.ppl
\end{verbatim}

