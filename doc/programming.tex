% PROGRAMMING.TEX
%
% The documentation in this file is part of PyXPlot
% <http://www.pyxplot.org.uk>
%
% Copyright (C) 2006-9 Dominic Ford <coders@pyxplot.org.uk>
%               2009   Ross Church
%
% $Id$
%
% PyXPlot is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% You should have received a copy of the GNU General Public License along with
% PyXPlot; if not, write to the Free Software Foundation, Inc., 51 Franklin
% Street, Fifth Floor, Boston, MA  02110-1301, USA

% ----------------------------------------------------------------------------

% LaTeX source for the PyXPlot Users' Guide

\chapter{Programming and Flow Control}

In this chapter we turn to the loop constructs which are available in PyXPlot,
which are principally useful for automatically executing a common set of
commands many times on many different \datafile s. We also explain how to
execute shell commands from within PyXPlot, and introduce a simple framework
for automatically re-executing PyXPlot scripts whenever they change, to allow
plots to update automatically whenever the scripts used to produce them are
modified.

\section{Conditionals}

The \indcmdt{if} can be used to conditionally execute a series of commands only
if a certain criterion is satisfied. In its simplest form, its syntax is

\begin{verbatim}
if <expression> {
  ....
 }
\end{verbatim}

\noindent where, as in C, the algebraic expression is deemed to be true if it
evaluates to any non-zero value, and to be false if it is exactly zero. The
list of commands to be executed must begin on a new line after the {\tt if}
statement, and the closing brace must be on a line by itself; alternatively,
semi-colons may, as always, be used in place of new lines. The opening brace
need not necessarily be on the same line as the {\tt if} statement, as is
demonstrated in the following example:

\begin{verbatim}
if (x==0)
 {
  print "x is zero"
 } else if (x>0) {
  print "x is positive"
 } else {
  print "x is negative"
 }
\end{verbatim}

In this example, the first script block, contained between the first pair of
braces, is executed if the first conditional, {\tt x==0}, is true. If the first
script block is not executed, PyXPlot proceeds to test the second conditional,
following the {\tt else if} statement, and executes the second script block if
this is true. The final script block is executed if all of the preceeding
conditionals have tested false. Any number of {\tt else if} statements can be
chained after one another, and a final {\tt else} statement can always be
optionally supplied. The {\tt else} and {\tt else if} statements must always be
placed on the same line as the closing brace of the preceeding script block.

The precise way in which a string of {\tt else if} statements are arranged in a
PyXPlot script is a matter of taste: the following is a more compact but
equivalent version of the example given above:

\begin{verbatim}
if      (x==0) { ; print "x is zero"     ; } \
else if (x> 0) { ; print "x is positive" ; } \
else           { ; print "x is negative" ; }
\end{verbatim}

\section{For Loops}

As in most programming languages, {\tt for} loops are used to execute a series
of lines several times. PyXPlot's \indcmdt{for} command is most similar to that
of the BASIC programming language, and has the syntax

\begin{verbatim}
for <variable> = <start> to <end> {step <step>}
 {
  ....
 }
\end{verbatim}

\noindent For example, the following script would run the supplied script block
repeatedly with different values of the variable {\tt x}, starting at zero,
increasing by two each time, and stopping once {\tt x} reaches ten. Thus, the
numbers 0, 2, 4, 6 and 8 would be printed:

\begin{verbatim}
for x = 0 to 10 step 2
 {
  print x
 }
\end{verbatim}

If no step size is supplied, then a unit step size is adopted. If a negative
step size is indicated, then the starting value of the loop variable must be
greater than the end value, otherwise an error is returned, since the loop
would otherwise run indefinitely. Likewise, if a step size of zero is
specified, an error is returned.

The same rules concerning the placement of brace characters apply to the
\indcmdt{for} command as to the {\tt if} command.

\section{Foreach Loops}

The \indcmdt{foreach} command may be used to run a script block once for every
file in the current working directory which matches a supplied file wildcard.
For example,

\begin{verbatim}
foreach x in *.dat
 {
  print x
 }
\end{verbatim}

\noindent would run the supplied script block once for every file in the
current working directory with a {\tt .dat} suffix. The effect would be rather
similar to typing

\begin{verbatim}
!ls *.dat
\end{verbatim}

An error is returned if there are no files in the present directory which match
the supplied wildcard. The following example would produce a plot of all of the
\datafile s in the current directory:

\begin{verbatim}
plot
foreach x in *.dat
 {
  replot x using 1:2
 }
\end{verbatim}

Alternatively, the \indcmdt{foreach} command may be used to run a script block
once for every value of a variable in a supplied list, as in

\begin{verbatim}
foreach x in (-1,pi,10)
 {
  print x
 }
\end{verbatim}

\noindent would print out the numbers $-1$, $\pi$ and 10.

\section{While and Do Loops}

The \indcmdt{while} command may be used to continue running a script block
until some stopping criterion is met. Two types of while loop are supported:

\begin{verbatim}
while <criterion>
 {
  ....
 }

do
 {
  ....
 } while <criterion>
\end{verbatim}
\indcmd{do}

The former example would execute the enclosed script block repeatedly, testing
the algebraic expression supplied to the \indcmdt{while} command immediately
before each repetition, and stopping if it tested false. The latter example is
very similar, but tests the supplied algebraic expression immediately {\it
after} each repetition. Thus, the former example may never actually execute the
supplied script block if the looping criterion tests false, but the latter
example is always guaranteed to run its script block at least once.

The following example would continue looping indefinitely until stopped by the
user:

\begin{verbatim}
while (1)
 {
  print "Hello, world!"
 }
\end{verbatim}

\example{ex:mandelbrot}{A script to produce an ASCII-art representation of the Mandelbrot Set}{
In this example, we use all of PyXPlot's loop constructs together in a script
which calculates the Mandelbrot Set and outputs an ASCII-art representation of
it to the terminal. Insert details about what the Mandelbrot Set is. The script is as follows: \vspace{0.5cm}\\

{\footnotesize\tt set numerics complex}\\
{\footnotesize\tt for~y=2~to~-2~step~-0.15}\\
{\footnotesize\tt ~\{}\\
{\footnotesize\tt ~~linebuffer~=~""}\\
{\footnotesize\tt ~~for~x=-2~to~2~step~0.075}\\
{\footnotesize\tt ~~~\{}\\
{\footnotesize\tt ~~~~zi~=~x+i*y;~z=zi;~iter=0;}\\
{\footnotesize\tt ~~~~while~(abs(z)<2)~and~(iter<21)}\\
{\footnotesize\tt ~~~~~\{}\\
{\footnotesize\tt ~~~~~~z~=~z**2~+~zi}\\
{\footnotesize\tt ~~~~~~iter=iter+1}\\
{\footnotesize\tt ~~~~~\}}\\
{\footnotesize\tt ~~~~if~~~~~~(iter~<~~1)~\{~;~linebuffer~="\%s~"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~~2)~\{~;~linebuffer~="\%s."\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~~4)~\{~;~linebuffer~="\%s-"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~20)~\{~;~linebuffer~="\%s*"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~~~~~~~~~~~~~~~~\{~;~linebuffer~="\%s\&"\%(linebuffer)~;~\}}\\
{\footnotesize\tt ~~~\}}\\
{\footnotesize\tt ~~print~linebuffer}\\
{\footnotesize\tt ~\}} \vspace{0.5cm}\\

The output of this script is as follows: \\

{\tt |~~~~~~~~~~~~~~~~~....................~~~~~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~............................~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~..................................~~~~~~~~~~}\newline
{\tt |~~~~~~~~......................................~~~~~~~~}\newline
{\tt |~~~~~~........-------------.....................~~~~~~}\newline
{\tt |~~~~~....--------------****-----.................~~~~~}\newline
{\tt |~~~~..----------------*******------................~~~}\newline
{\tt |~~~.---------------*****\&\&\&****------...............~~}\newline
{\tt |~~.-------------***\&***\&\&\&\&\&*****-----..............~~}\newline
{\tt |~.---------********\&\&\&\&\&\&\&\&\&\&\&\&\&**-----..............~}\newline
{\tt |~------**********\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&*------.............~}\newline
{\tt |~----******\&\&\&\&\&*\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&*------..............}\newline
{\tt |~********\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~---*****\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~-----*****\&\&\&\&\&*\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~-------***********\&\&\&\&\&\&\&\&\&\&\&\&\&**------.............~}\newline
{\tt |~~----------*******\&\&\&\&\&\&\&\&\&\&\&\&\&**-----..............~}\newline
{\tt |~~.--------------*******\&\&\&******-----..............~~}\newline
{\tt |~~~..---------------*****\&****------...............~~~}\newline
{\tt |~~~~...---------------******------................~~~~}\newline
{\tt |~~~~~.....---------------------..................~~~~~}\newline
{\tt |~~~~~~~..........-------.......................~~~~~~~}\newline
{\tt |~~~~~~~~~.....................................~~~~~~~~}\newline
{\tt |~~~~~~~~~~~................................~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~~..........................~~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~~~~~~~................~~~~~~~~~~~~~~~~~~~}\\
}

\section{The \indcmdt{exec}}

The \indcmdt{exec} can be used to execute PyXPlot commands contained within
string variables. For example:

\begin{verbatim}
terminal="eps"
exec "set terminal %s"%(terminal)
\end{verbatim}

It can also be used to write obfuscated PyXPlot scripts.

\section{Shell Commands}

Shell commands\index{shell commands!executing} may be executed directly from
within PyXPlot by prefixing them with an \indcmdts{!} character. The
remainder of the line is sent directly to the shell, for example:

\begin{verbatim}
!ls -l
\end{verbatim}

\noindent Semi-colons cannot be used to place further PyXPlot commands after a
shell command on the same line.

\begin{dontdo}
!ls -l ; set key top left
\end{dontdo}

It is also possible to substitute the output of a shell command into a PyXPlot
command. To do this, the shell command should be enclosed in back-quotes (`).
For example:\index{backquote character}\index{shell commands!substituting}

\begin{verbatim}
a=`ls -l *.ppl | wc -l`
print "The current directory contains %d PyXPlot scripts."%(a)
\end{verbatim}

It should be noted that back-quotes can only be used outside quotes. For
example:

\begin{dontdo}
set xlabel '`ls`'
\end{dontdo}

\noindent will not work. The best way to do this would be:

\begin{dodo}
set xlabel `echo "'" ; ls ; echo "'"`
\end{dodo}

Note that it is not possible to change the current working directory by sending
the {\tt cd} command to a shell, as this command would only change the working
directory of the shell in which the single command is executed:

\begin{dontdo}
!cd ..
\end{dontdo}

PyXPlot has its own \indcmdt{cd} for this purpose, as well as its own
\indcmdt{pwd}:

\begin{dodo}
cd ..
\end{dodo}

\section{Script Watching: pyxplot\_watch}

PyXPlot includes a simple tool for watching command script files and executing
them whenever they are modified. This may be useful when developing a command
script, if one wants to make small modifications to it and see the results in a
semi-live fashion. This tool is invoked by calling the {\tt
pyxplot\_watch}\index{pyxplot\_watch}\index{watching scripts} command from a
shell prompt. The command-line syntax of {\tt pyxplot\_watch} is similar to
that of PyXPlot itself, for example:

\begin{verbatim}
pyxplot_watch script.ppl
\end{verbatim}

\noindent would set {\tt pyxplot\_watch} to watch the command script file
{\tt script.ppl}. One difference, however, is that if multiple script files are
specified on the command line, they are watched and executed independently,
\textit{not} sequentially, as PyXPlot itself would do. Wildcard characters can
also be used to set {\tt pyxplot\_watch} to watch multiple
files.\footnote{Note that {\tt pyxplot\_watch *.script} and
{\tt pyxplot\_watch $\backslash$*.script} will behave differently in most
UNIX shells.  In the first case, the wildcard is expanded by your shell, and a
list of files passed to {\tt pyxplot\_watch}. Any files matching the
wildcard, created after running {\tt pyxplot\_watch}, will not be picked up.
In the latter case, the wildcard is expanded by {\tt pyxplot\_watch} itself,
which {\it will} pick up any newly created files.}

This is especially useful when combined with \ghostview's\index{Ghostview}
watch facility. For example, suppose that a script {\tt foo.ppl} produces
postscript output {\tt foo.ps}. The following two commands could be used to
give a live view of the result of executing this script:

\begin{verbatim}
gv --watch foo.ps &
pyxplot_watch foo.ppl
\end{verbatim}

