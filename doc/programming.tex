% PROGRAMMING.TEX
%
% The documentation in this file is part of PyXPlot
% <http://www.pyxplot.org.uk>
%
% Copyright (C) 2006-9 Dominic Ford <coders@pyxplot.org.uk>
%               2009   Ross Church
%
% $Id$
%
% PyXPlot is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% You should have received a copy of the GNU General Public License along with
% PyXPlot; if not, write to the Free Software Foundation, Inc., 51 Franklin
% Street, Fifth Floor, Boston, MA  02110-1301, USA

% ----------------------------------------------------------------------------

% LaTeX source for the PyXPlot Users' Guide

\chapter{Performing Calculations}

This chapter describes how PyXPlot may be used as a sophisticated calculator.

\section{Variables}

PyXPlot recognises two types of variables: numeric variables and string
variables.  The former can be assigned using any valid mathematical expression.
For example:

\begin{verbatim}
a = 5.2 * sqrt(64)
\end{verbatim}

\noindent would assign the value 41.6 to the variable {\tt a}.  Numerical variables can
subsequently be used in mathematical expressions themselves, for example:

\begin{verbatim}
a=2*pi
plot [0:1] sin(a*x)
\end{verbatim}

\noindent String variables can be assigned in an analogous manner, by enclosing
the string in quotation marks. They can then be used wherever a quoted string
could be used, for example as a filename or a plot title, as
in:\index{variables!string}

\begin{verbatim}
plotname = "The Growth of a Rabbit Population"
set title plotname
\end{verbatim}

String variables can be modified using the search-and-replace string
operator\index{string operators!search and replace}\footnote{Programmers with
experience of {\tt perl} will recognise this syntax.}, =$\sim$\index{=$\sim$
operator}, which takes a regular expression with a syntax similar to that
expected by the shell command {\tt sed}\index{sed shell command@{\tt sed} shell
command} and applies it to the relevant string.\footnote{Regular expression
syntax is a massive subject, and is beyond the scope of this manual. The
official GNU documentation for the {\tt sed} command is heavy reading, but
there are many more accessible tutorials on the web.}\index{regular
expressions} For example:

\begin{verbatim}
twister="seven silver soda syphons"
twister =~ s/s/th/
print twister
\end{verbatim}

Note that only the {\tt s} (substitute) command of {\tt sed} is implemented in
PyXPlot. Any character can be used in place of the {\tt /} characters in the
above example, for example:

\begin{verbatim}
twister =~ s@s@th@
\end{verbatim}

\noindent Flags can be passed, as in {\tt sed} or {\tt perl}, for example:

\begin{verbatim}
twister =~ s@s@th@g
\end{verbatim}

\noindent Table~\ref{tab:re_flags} lists all of the regular expression flags
recognised by the =$\sim$ operator.

\begin{table}
\framebox[\textwidth]{\footnotesize
\begin{tabular}{p{5mm}p{10.5cm}}
{\tt g} & Replace {\it all} matches of the pattern; by default, only the first match is replaced. \\
{\tt i} & Perform case-insensitive matching, such that expressions like {\tt [A-Z]} will match lowercase letters, too. \\
{\tt l} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the current locale. \\
{\tt m} & When specified, the pattern character {\tt \^{}} matches the beginning of the string and the beginning of each line immediately following each newline. The pattern character {\tt \$} matches at the end of the string and the end of each line immediately preceding each newline. By default, {\tt \^{}} matches only the beginning of the string, and {\tt \$} only the end of the string and immediately before the newline, if present, at the end of the string. \\
{\tt s} & Make the {\tt .} special character match any character at all, including a newline; without this flag, {\tt .} will match anything except a newline. \\
{\tt u} & Make {\tt $\backslash$w}, {\tt $\backslash$W}, {\tt $\backslash$b}, {\tt $\backslash$B}, {\tt $\backslash$s} and {\tt $\backslash$S} dependent on the Unicode character properties database. \\
{\tt x} & This flag allows the user to write regular expressions that look nicer. Whitespace within the pattern is ignored, except when in a character class or preceded by an unescaped backslash. When a line contains a {\tt \#}, neither in a character class or preceded by an unescaped backslash, all characters from the leftmost such {\tt \#} through the end of the line are ignored. \\
\end{tabular}}
\caption{A list of the flags accepted by the =$\sim$ operator. Most are rarely used, but the {\tt g} flag is very useful.}
\label{tab:re_flags}
\end{table}

Strings may also be put together using the string substitution operator, {\tt
\%}\index{\% operator@{\tt \%} operator}, which works in a similar fashion to
Python string substitution operator\index{string operators!substitution}. This
is described in detail in Section~\ref{sec:string_subs_op}.  For example, to
concatenate the two strings contained in variables {\tt a} and {\tt b} into
variable {\tt c} one would run:\index{string operators!concatenation}

\begin{verbatim}
c = "%s%s"%(a,b)
\end{verbatim}

One common practical application of these string operators is to label plots
with the title of the \datafile\ being plotted, as in:

\begin{verbatim}
filename="data_file.dat"
title="A plot of the data in {\tt %s}."%(filename)
title=~s/_/\_/g # Underscore is a reserved character in LaTeX
set title title
plot filename
\end{verbatim}

\section{Handling Numerical Errors}
\label{sec:num_errs}
\index{numerical errors}

By default, an error message is returned whenever calculations return values
which are infinite, as in the case of {\tt 1/0}, or when functions are
evaluated outside the range of parameter space in which they are defined, as in
the case of {\tt besseli(-1,1)}.  Sometimes this behaviour is desirable: it
flags up to the user that a calculation has gone wrong, and exactly what the
problem is.  At other times, however, these error messages can be undesirable.
For example, when plotting the function {\tt sqrt(x)} between $x=-1$ and $x=1$,
error messages about the function being undefined for $x<0$ may seem as
unnecessary spam, and may indeed lead you to miss more genuine and serious
errors buried in their midst.

For this reason, the issuing of explicit error messages when calculations
return non-finite numeric results can be switched off by typing
\indcmd{set numeric errors quiet}

\begin{verbatim}
set numeric errors quiet
\end{verbatim}

\noindent Having done this, expressions such as

\begin{verbatim}
x = besseli(-1,1)
\end{verbatim}

\noindent fail silently, and variables which contain non-finite numeric results
are displayed as {\tt NaN}\index{NaN}, which stands for {\it Not a
Number}\index{not a number}.

The issuing of explicit errors may subsequently be re-enabled by typing
\indcmd{set numeric errors explicit}

\begin{verbatim}
set numeric errors explicit
\end{verbatim}

\section{Working with Complex Numbers}
\label{sec:complex_numbers}
\index{complex numbers}

In all of the examples given thus far, algebraic expressions have only been
allowed to return real numbers: PyXPlot has not been handling any complex
numbers. Since there are many circumstances in which you may be analysing data
which you are certain is real, complex arithmetic is disabled by default.
Expressions such as {\tt sqrt(-1)} will return either an error or {\tt NaN}.
The most obvious example of this is the built-in variable {\tt i}, which is set
to equal {\tt sqrt(-1)}:

\begin{verbatim}
pyxplot> print i
nan
\end{verbatim}

Complex arithmetic may be enabled by typing
\indcmd{set numeric complex}

\begin{verbatim}
set numeric complex
\end{verbatim}

\noindent and then disabled again by typing
\indcmd{set numeric real}

\begin{verbatim}
set numeric real
\end{verbatim}

Once complex arithmetic is enabled, many of PyXPlot's built in mathematical
functions accept complex input arguments, including the logarithm function, all
of the trigonometric functions, and the exponential function; a complete list
of functions which accept complex inputs can be found in
Appendix~\ref{ch:function_list}.

Complex number literals can be entered into algebraic expressions in either of
the following two forms:

\begin{verbatim}
print (2 + 3*i       )
print (2 + 3*sqrt(-1))
\end{verbatim}

\noindent The former version depends upon the built-in system variable {\tt i}
being defined to equal $\sqrt{-1}$; the user could stop this from working if he
had previous typed, for example

\begin{verbatim}
i=1
\end{verbatim}

\noindent However, the variable {\tt i} can straightforwardly be returned to
its default value by typing

\begin{verbatim}
i=sqrt(-1)
\end{verbatim}

Several functions are provided especially for performing manipulations on
complex numbers: the \indfunt{Re(z)} and \indfunt{Im(z)} functions return
respectively the real and imaginary parts of a complex number $z$, the
\indfunt{arg(z)} function returns the complex argument of $z$, and the
\indfunt{abs(z)} function returns the modulus of $z$. For example:

\begin{verbatim}
set numeric complex
x=0.5
print Re(exp(i*x))
print cos(x)        # This equals the above
print arg(exp(i*x)) # This equals x
\end{verbatim}

\section{Working with Physical Units}
\label{sec:units}
\index{physical units}\index{units}

PyXPlot has extensive facilities for handling data which is read in from files
which use different physical units, and these features also make it a powerful
desktop tool for converting quantities between different imperial and metric
units, and for doing simple back-of-the-envelope calculations where numbers are
substituted into equations and you want to know what the dimensions of the
quantity you've calculated is.

All numeric variables in PyXPlot have not only a numeric magnitude, but also a
physical unit associated with them. In the case a pure number such as~2, the
quantity is said to be dimensionless: it has no physical unit. The special
function \indfunt{unit()} is used to change the physical unit associated with a
quantity. For example, the expression

\begin{verbatim}
print 2*unit(s)
\end{verbatim}

\noindent takes the number~2 and multiplies it by the unit {\tt s}, which is
the SI abbreviation for seconds.  The resulting quantity then has dimensions of
time, and could, for example, be divided by the unit {\tt hr} to find the
dimensionless number of hours in two seconds:

\begin{verbatim}
print 2*unit(s)/unit(hr)
\end{verbatim}

\begin{boxout}\index{units!angle}\index{angles, handling of}
By convention, the SI system of units does not have a base unit of angle:
instead, the radian is considered to be a dimensionless unit.  There are some
strong mathematical reasons why this makes sense, since it makes it possible to
write equations such as
\begin{displaymath}
d=\theta r
\end{displaymath}
and
\begin{displaymath}
x = \exp(a+i\theta).
\end{displaymath}
However, it also has some disadvantages: some interesting quantities are
measured per unit angle or per unit solid angle, and the SI system offers no
way to dimensionally distinguish these from one another or from quantities with
no angular dependence.

On balance, we have decided that it is more useful if PyXPlot {\it does}
consider the radian to be a base unit, so that it can understand quantities
such as radiative fluxes measured per steradian. The unfortunate consequence of
this is that first equation above to be rewritten as:
\begin{displaymath}
d=\left(\frac{\theta}{2\pi\,\mathrm{rad}}\right) r
\end{displaymath}

As compensation, the $\exp()$ function and all of the trigonometric functions
accept either quantities with dimensions of angles, or dimensionless numbers as
inputs. The second equation above might need some modification, however, since
it is not possible to add a dimensionless number to an angle.
\caption{A note on the use of the radian is a base unit in PyXPlot.}
\end{boxout}

Compound units such as miles per hour, which is defined in terms of two other
units, can be used thus

\begin{verbatim}
print 2*unit(miles/hour)
\end{verbatim}

\noindent or, in many cases, have their own explicit abbreviations, in this
case {\tt mph}:

\begin{verbatim}
print 2*unit(mph)
\end{verbatim}

\noindent As these examples demonstrate, the {\tt unit()} function can be
passed a string of units either multiplied together with the {\tt *} operator,
or divided using the {\tt /} operator. Units may be raised to powers with the
{\tt **} operator\footnote{The {\tt \^{}} character may be used as an alias for
the {\tt **} operator, though this notation is arguably confusing, since the
same character is used for the binary exclusive or operator in PyXPlot's normal
arithmetic.}, as in

\begin{verbatim}
a = 2*unit(m**2)
print "An area of %f square feet"%(a/unit(ft**2))
\end{verbatim}

\noindent As these examples also demonstrate, units may be refered to either by
their abbreviated or full names, and either in their singular or plural forms.
A complete list of all of the units which PyXPlot recognises by default,
together with all of their recognised names can be found in
Appendix~\ref{ch:unit_list}.

SI units may also be preceded with SI prefixes\index{units!SI prefixes}, for
example:

\begin{verbatim}
a = 2*unit(um)
a = 2*unit(micrometres)
\end{verbatim}

When quantities with physical units are substituted into algebraic expressions,
PyXPlot automatically checks that the expression is dimensionally correct
before evaluating it. For example, the following expression is not
dimensionally correct and would return an error because the first term in the
sum has dimensions of velocity, meanwhile the second term is a length:
\index{units!dimensional analysis}

\begin{verbatim}
a = 2*unit(m)
b = 4*unit(s)
print a/b + a
\end{verbatim}

\noindent PyXPlot continues to throw an error in this case, even when explicit
numerical errors are turned off with the \indcmdt{set numeric errors quiet},
since it is deemed a serious error: the above expression would never be correct
for any values of {\tt a} and {\tt b} given their dimensions.

As a quick perusal of Appendix~\ref{ch:unit_list} will show, a large number of
units are pre-defined in PyXPlot by default. However, the need may occasionally
arise to define new units. It is not possible to do this from an interactive
PyXPlot terminal, but it is possible to do so from a configuration script which
PyXPlot runs upon start-up. This will be discussed in
Chapter~\ref{ch:configuration}, where we shall also see that new base units can
also be defined. Just as the Pluto mass can be defined as a new measure of
mass, so the potato can be defined as a new measure of number of vegetables.

\subsection{Converting between different Temperature Scales}
\index{temperature conversions}\index{units!temperature}

PyXPlot's facilities for converting quantities between different physical units
include the ability to convert temperatures between different temperature
scales, for example, between $^\circ\mathrm{C}$, $^\circ\mathrm{F}$ and K.
However, these conversions have some subtleties, unique to temperature
conversions, which mean that they should be used with some caution. Consider
the following two questions:
\begin{itemize}
\item How many degrees Kelvin corresponds to a temperature of $20^\circ$C?
\item How many degrees Kelvin corresponds to a temperature {\it rise} of $20^\circ$C?
\end{itemize}
The answers to these two questions are 293\,K and 20\,K respectively: we see
that although we are converting from $20^\circ$C in both cases, the
corresponding number of Kelvin depends upon whether we are talking about an
{\it absolute} temperature or a {\it relative} temperature. A heat capacity of
1\,J/$^\circ$C equals 1\,J/K, even though $1^\circ$C does not equal 1\,K.

The cause of this problem, and the reason why it rarely affects any physical
units other than temperatures is that there exists such a thing as absolute
temperature. Distances, for example, are very rarely absolute: they measure
relative distance gaps between points. Occasionally people might choose to
express all their displacements relative to a particular origin, but they
wouldn't expect PyXPlot to be able to convert these into displacements from
another origin. But they might expect it to be able to convert temperatures
between Celsius and Fahrenheit, even though the problem of doing so is
equivalent.

Times are occasionally expressed as absolute quantities: the year 1453, for
example, implicitly corresponds to 1453 years since the Christian epoch.
Similar problems would arise in trying to convert such a year into the Muslim
calendar, which counts from the year {\footnotesize AD} 622, to those of
encountered in converting between temperature scales.\footnote{PyXPlot can,
incidentally, make this conversion, as will be seen in
Section~\ref{sec:time_series}.}

As PyXPlot cannot distinguish between absolute and relative temperatures, it
takes a safe approach of performing algebra consistently with any unit of
temperature, never performing automatic conversions between different
temperature scales. A calculation based on temperatures measured in
$^\circ\mathrm{F}$ will produce an answer measured in $^\circ\mathrm{F}$.
However, as converting temperatures between temperature scales is a useful task
which is often wanted, this is allowed, when specifically requested, in the
specific case of dividing one temperature by another unit of temperature to get
a dimensionless number, as in the following example:

\begin{dodo}
print 98*unit(oF) / unit(oC)
\end{dodo}

\noindent Note that the two units of temperature must be placed in separate
{\tt unit(...)} functions. The following is not allowed:

\begin{dontdo}
print 98*unit(oF / oC)
\end{dontdo}

Note that such a conversion always assumes that the temperatures supplied are
{\it absolute} temperatures. PyXPlot has no facility for converting relative
temperatures between different scales. This must be done manually.

The conversion of derived units of temperature, such as $\mathrm{J}/\mathrm{K}$ or
$^\circ\mathrm{C}^2$, to derived units of other temperature scales, such as
$\mathrm{J}/^\circ\mathrm{F}$ or $\mathrm{K}^2$, is not permitted, since in
general these conversions are ill-defined. For example, a temperature squared
measured in $^\circ\mathrm{C}^2$ has the same value for $\pm
x^\circ\mathrm{C}$, but would have different values in $\mathrm{K}^2$.

The moral of this story is: pick what unit of temperature you want to work in,
convert all of your temperatures to that scale, and then stick to it.

\section{Configuring how Numbers are Displayed}
\label{sec:unitdisp}

\subsection{Units}

By default, when a number which has physical dimensions is displayed PyXPlot
searches through its database of physical units for the most appropriate unit
in which to represent it. The name of the adopted unit is printed after the
value. By default, quantities are displayed by preference in SI units, and SI
prefixes such as milli- or kilo- are applied where appropriate. All of the
behaviour, however, can be configured.

PyXPlot has a number of different {\it units schemes}\index{units!unit
schemes}, each of which comprises a list of units which are to be used in
preference to all others. For example, in the CGS unit scheme\index{CGS
units}\index{units!CGS}, all lengths are displayed in centimetres, all masses
are displayed in grammes, and so forth. In the imperial unit
scheme\index{imperial units}\index{units!imperial}, quantities are displayed in
British imperial units, meanwhile in the US unit scheme, US customary units are
used. The current unit scheme can be changed using the \indcmdt{set unit
scheme}:

\begin{verbatim}
pyxplot> vol = 3*unit(m**3)
pyxplot> set unit scheme si ; print vol
3 cubic_m
pyxplot> set unit scheme cgs ; print vol
3000000 cubic_cm
pyxplot> set unit scheme imperial ; print vol
82.488468 bushels_(UK)
pyxplot> set unit scheme us ; print vol
85.13278 bushels_(US)
\end{verbatim}

\noindent A complete list of PyXPlot's unit schemes can be found in
Table~\ref{tab:unit_schemes}.\index{natural units}\index{units!natural}

\begin{table}
\framebox[\textwidth]{
\begin{tabular}{lp{9cm}}
{\bf Name} & {\bf Description} \\
\hline
{\tt ancient} & Ancient units, especially those used in the Authorised Version of the Bible. \\
{\tt CGS} & CGS units. \\
{\tt Imperial} & British imperial units. \\
{\tt Planck} & Planck units, also known as natural units, which make several physical constants equal unity. \\
{\tt SI} & SI units. \\
{\tt US} & US customary units. \\
\hline
\end{tabular}}
\caption{A list of PyXPlot's unit schemes.}
\label{tab:unit_schemes}
\end{table}

In some cases, one may want to broadly use one of these unit schemes, but
override one of the units in favour of another.  Astronomers, for example, may
wish to use SI or CGS units to express all quantities with the exception of
distances, which they wish to express in parsecs or astronomical units. Another
astronomer might wish to express masses in solar or Jupiter masses, or
luminosities in solar luminosities. This level of control is made available
through the \indcmdt{set unit of} command, for example:

\begin{verbatim}
set unit of length parsec
set unit of mass Mjupiter
\end{verbatim}

The more unusual case of the astronomer who wishes to express masses in Pluto
masses is more complicated: the Pluto mass is not a pre-defined unit in
PyXPlot, and it must first be defined before it can be set as a default unit.
In Chapter~\ref{ch:configuration}, we shall see how to define new units in a
configuration script.

By default, units are displayed in their abbreviated forms, for example {\tt A} for amperes, and SI prefixes such as milli- and kilo- are applied to SI units where they are appropriate.\index{SI prefixes}\index{units!SI prefixes} In both cases, this behaviour
can be turned on or off, in the former case with the commands:

\begin{verbatim}
set unit display abbreviated
set unit display full
\end{verbatim}

\noindent and in the latter case using the following pair of commands:

\begin{verbatim}
set unit display prefix
set unit display noprefix
\end{verbatim}

\subsection{Changing the Accuracy to which Numbers are Displayed}

By default, when a number is displayed, it is printed accurate to eight
significant figures, although fewer figures may actually be displayed if the
final digits are zeros or nines.

This is generally a helpful convention: PyXPlot's internal arithmetic is
generally accurate to around 16 significant figures, and so it is quite
conceivable that a calculation which is supposed to return, say $1$, may in
fact return 0.999\,999\,999\,999\,999\,9. Likewise, when complex arithmetic is
enabled, routines which are expected to return real numbers may in fact return
results with imaginary parts at the level of one part in $10^{16}$.  By
displaying numbers to only eight significant figures in such cases, the user is
usually shown the `right' answer, instead of a noisy and unattractive one.

However, there may also be cases where more accuracy is desirable, in which
case, the number of significant figures to which output is displayed can be set
using the command\indcmd{set numerics sigfig}

\begin{verbatim}
n = 12
set numerics sigfig n
\end{verbatim}

\noindent where {\tt n} can be any number in the range 1-30. It should be noted
that the number supplied is the {\it minimum} number of significant figures to
which numbers are displayed; on occasion an extra figure may be displayed.

Alternatively, the string substitution operator, described in
Section~\ref{sec:string_subs_op} may be used to specify how a number should be
displayed on a one-by-one basis, for example:

\begin{verbatim}
print "%d"  %(pi) # Print the integer part of pi
print "%.5f"%(pi) # Print pi in non-scientific format, to
                  #   5 decimal places
print "%.5e"%(pi) # Print pi in scientific format, to
                  #   5 decimal places
print "%s"  %(pi) # Print pi as normal
\end{verbatim}

\subsection{Creating Pastable Text}
\label{sec:pastable}

PyXPlot's default convention of displaying numbers in a format such as

\begin{verbatim}
(2+3i) metres
\end{verbatim}

is well-suited for creating text which is readable by human users, but is less
well-suited for creating text which can be copied and pasted into another
calculation in another PyXPlot terminal, or for creating text which could be
used in a \LaTeX\ text label on a plot. For this reason, the \indcmdt{set
numerics display} command allows the user to choose between three different
ways in which numbers can be displayed:

\begin{verbatim}
pyxplot> set numerics display natural
pyxplot> print phy_c
299792 km/s
pyxplot> set numerics display typeable
pyxplot> print phy_c
299792*unit(km/s)
pyxplot> set numerics display latex
pyxplot> print phy_c
$299792\,\mathrm{km}/\mathrm{s}$
\end{verbatim}

The first case is the default way in which PyXPlot displays numbers. The second
case produces text which forms a valid algebraic expression which could be
pasted into another PyXPlot calculation. The final case produces a string of
\LaTeX\ text which could be used as a label on a plot.

\section{Physical Constants}
\label{sec:constants}
\index{physical constants}\index{constants}

A wide range of mathematical and physical constants are defined by default in
PyXPlot: most of the physical constants are prefixed with {\tt phy\_} to
minimise name clashes with variables which the user may wish to define,
although it is not an error for the user to redefine any of the built-in
variables.

These physical constants make it easy to evaluate physical formulae without
explicitly looking up their values, as well as having a wide range of other
uses. For example, the default aspect ratio of plots is the golden ratio,
$\left((1+\sqrt{5})/2\right)^{-1}$, whose value is also contained in the
constant {\tt GoldenRatio}.\index{golden ratio} Thus, the statement

\begin{verbatim}
set size ratio 1/GoldenRatio
\end{verbatim}

\noindent is entirely equivalent to setting plots to have the automatic aspect
ratio. To obtain a square grid on a plot of the default aspect ratio, it is
necessary that the range of the vertical axis should be {\tt 1/GoldenRatio}
times that of the horizontal axis:

\begin{verbatim}
x0 = 0 ; y0 = 0; xspan = 2
set xrange[x0 - xspan/2            :x0 + xspan/2             ]
set yrange[y0 - xspan/2/GoldenRatio:y0 + xspan/2/GoldenRatio ]
\end{verbatim}

\section{User-defined Functions}
\index{function splicing}
\index{splicing functions}

In PyXPlot, as in \gnuplot, user-defined functions may be declared on the
command line:

\begin{verbatim}
f(x) = x*sin(x)
\end{verbatim}

\noindent It is also possible to declare functions which are valid only over
certain ranges of argument space. For example, the following function would
only be valid within the range $-2<x<2$:\footnote{The syntax {\tt [-2:2]} can
also be written {\tt [-2 to 2]}.}

\begin{verbatim}
f(x)[-2:2] = x*sin(x)
\end{verbatim}

\noindent The following function would only be valid when all of ${a,b,c}$ were
in the range $-1 \to 1$:

\begin{verbatim}
f(a,b,c)[-1:1][-1:1][-1:1] = a+b+c
\end{verbatim}

If an attempt is made to evaluate a function outside of its specified range,
then an error results. This may be useful, for example, for plotting a function
only within some specified range. The following would plot the function
$\sinc(x)$, but only in the range $-2<x<7$:

\begin{verbatim}
f(x)[-2:7] = sin(x)/x
plot f(x)
\end{verbatim}

\example{ex:funcsplice1}{A simple example of the use of function splicing to truncate a function}{
A simple example of the use of function splicing to truncate the function $\sinc(x)$ at $x=-2$ and $x=7$. See details in the text.\\
\begin{center}
\includegraphics{examples/eps/ex_funcsplice1.eps}
\end{center}
}

\noindent The output of this particular example can be seen in
Example~\ref{ex:funcsplice1}. A similar effect could also have been achieved
with the {\tt select} keyword; see Section~\ref{sec:select_modifier}.

It is possible to make multiple declarations of the same function, over
different regions of argument space; if there is an overlap in the valid
argument space for multiple definitions, then later declarations take
precedence. This makes it possible to use different functional forms for
functions in different parts of parameter space, and is especially useful when
fitting functions to data, if different functional forms are to be spliced
together to fit different regimes in the data.

Another application of function splicing is to work with functions which do not
have analytic forms, or which are, by definition, discontinuous, such as
top-hat functions or Heaviside functions. The following example would define
$f(x)$ to be a Heaviside function:

\begin{verbatim}
f(x) = 0
f(x)[0:] = 1
\end{verbatim}

\noindent The following example would define $f(x)$ to follow the Fibonacci
sequence, though it is not at all computationally efficient, and it is
inadvisable to evaluate it for $x\gtrsim8$:

\begin{verbatim}
f(x) = 1
f(x)[2:] = f(x-1) + f(x-2)
plot [0:8] f(x)
\end{verbatim}

\example{ex:funcsplice2}{An example of the use of function splicing to define a function which does not have an analytic form}{
An example of the use of function splicing to define a function which does not have an analytic form -- in this case, the Fibonacci sequence. See the text for details.\\
\begin{center}
\includegraphics{examples/eps/ex_funcsplice2.eps}
\end{center}
}

\noindent The output of this example can be seen in Example~\ref{ex:funcsplice2}

\section{Working with Time-Series Data}
\label{sec:time_series}

\begin{verbatim}
set calendar british
x = time_juliandate(2000,1,1,0,0,0)
print time_diff(x, time_now())
print time_diff_string(x, time_now())

x = time_now()
print time_string(x)

set calendar julian

print time_string(x)
print time_string(time_now())

set calendar input russian output british
x = time_juliandate(1828,8,28,0,0,0)
print time_string(x)

set calendar islamic
print time_string(time_now())

set calendar hebrew
print time_string(time_now())
\end{verbatim}



\chapter{Programming and Flow Control}

In this chapter we turn to the loop constructs which are available in PyXPlot,
which are principally useful for automatically executing a common set of
commands many times on many different \datafile s. We also explain how to
execute shell commands from within PyXPlot, and introduce a simple framework
for automatically re-executing PyXPlot scripts whenever they change, to allow
plots to update automatically whenever the scripts used to produce them are
modified.

\section{Conditionals}

The \indcmdt{if} can be used to conditionally execute a series of commands only
if a certain criterion is satisfied. In its simplest form, its syntax is

\begin{verbatim}
if <expression> {
  ....
 }
\end{verbatim}

\noindent where, as in C, the algebraic expression is deemed to be true if it
evaluates to any non-zero value, and to be false if it is exactly zero. The
list of commands to be executed must begin on a new line after the {\tt if}
statement, and the closing brace must be on a line by itself; alternatively,
semi-colons may, as always, be used in place of new lines. The opening brace
need not necessarily be on the same line as the {\tt if} statement, as is
demonstrated in the following example:

\begin{verbatim}
if (x==0)
 {
  print "x is zero"
 } else if (x>0) {
  print "x is positive"
 } else {
  print "x is negative"
 }
\end{verbatim}

In this example, the first script block, contained between the first pair of
braces, is executed if the first conditional, {\tt x==0}, is true. If the first
script block is not executed, PyXPlot proceeds to test the second conditional,
following the {\tt else if} statement, and executes the second script block if
this is true. The final script block is executed if all of the preceeding
conditionals have tested false. Any number of {\tt else if} statements can be
chained after one another, and a final {\tt else} statement can always be
optionally supplied. The {\tt else} and {\tt else if} statements must always be
placed on the same line as the closing brace of the preceeding script block.

The precise way in which a string of {\tt else if} statements are arranged in a
PyXPlot script is a matter of taste: the following is a more compact but
equivalent version of the example given above:

\begin{verbatim}
if      (x==0) { ; print "x is zero"     ; } \
else if (x> 0) { ; print "x is positive" ; } \
else           { ; print "x is negative" ; }
\end{verbatim}

\section{For Loops}

As in most programming languages, {\tt for} loops are used to execute a series
of lines several times. PyXPlot's \indcmdt{for} command is most similar to that
of the BASIC programming language, and has the syntax

\begin{verbatim}
for <variable> = <start> to <end> {step <step>}
 {
  ....
 }
\end{verbatim}

\noindent For example, the following script would run the supplied script block
repeatedly with different values of the variable {\tt x}, starting at zero,
increasing by two each time, and stopping once {\tt x} reaches ten. Thus, the
numbers 0, 2, 4, 6 and 8 would be printed:

\begin{verbatim}
for x = 0 to 10 step 2
 {
  print x
 }
\end{verbatim}

If no step size is supplied, then a unit step size is adopted. If a negative
step size is indicated, then the starting value of the loop variable must be
greater than the end value, otherwise an error is returned, since the loop
would otherwise run indefinitely. Likewise, if a step size of zero is
specified, an error is returned.

The same rules concerning the placement of brace characters apply to the
\indcmdt{for} command as to the {\tt if} command.

\section{Foreach Loops}

The \indcmdt{foreach} command may be used to run a script block once for every
file in the current working directory which matches a supplied file wildcard.
For example,

\begin{verbatim}
foreach x in *.dat
 {
  print x
 }
\end{verbatim}

\noindent would run the supplied script block once for every file in the
current working directory with a {\tt .dat} suffix. The effect would be rather
similar to typing

\begin{verbatim}
!ls *.dat
\end{verbatim}

An error is returned if there are no files in the present directory which match
the supplied wildcard. The following example would produce a plot of all of the
\datafile s in the current directory:

\begin{verbatim}
plot
foreach x in *.dat
 {
  replot x using 1:2
 }
\end{verbatim}

Alternatively, the \indcmdt{foreach} command may be used to run a script block
once for every value of a variable in a supplied list, as in

\begin{verbatim}
foreach x in (-1,pi,10)
 {
  print x
 }
\end{verbatim}

\noindent would print out the numbers $-1$, $\pi$ and 10.

\section{While Loops}

The \indcmdt{while} command may be used to continue running a script block
until some stopping criterion is met. Two types of while loop are supported:

\begin{verbatim}
while <criterion>
 {
  ....
 }

do
 {
  ....
 } while <criterion>
\end{verbatim}
\indcmd{do}

The former example would execute the enclosed script block repeatedly, testing
the algebraic expression supplied to the \indcmdt{while} command immediately
before each repetition, and stopping if it tested false. The latter example is
very similar, but tests the supplied algebraic expression immediately {\it
after} each repetition. Thus, the former example may never actually execute the
supplied script block if the looping criterion tests false, but the latter
example is always gauranteed to run its script block at least once.

The following example would continue looping indefinitely until stopped by the
user:

\begin{verbatim}
while (1)
 {
  print "Hello, world!"
 }
\end{verbatim}

\example{ex:mandelbrot}{A script to produce an ASCII-art representation of the Mandelbrot Set}{
In this example, we use all of PyXPlot's loop constructs together in a script
which calculates the Mandelbrot Set and outputs an ASCII-art representation of
it to the terminal. Insert details about what the Mandelbrot Set is. The script is as follows: \vspace{0.5cm}\\

{\footnotesize\tt set numerics complex}\\
{\footnotesize\tt for~y=2~to~-2~step~-0.15}\\
{\footnotesize\tt ~\{}\\
{\footnotesize\tt ~~linebuffer~=~""}\\
{\footnotesize\tt ~~for~x=-2~to~2~step~0.075}\\
{\footnotesize\tt ~~~\{}\\
{\footnotesize\tt ~~~~zi~=~x+i*y;~z=zi;~iter=0;}\\
{\footnotesize\tt ~~~~while~(abs(z)<2)~and~(iter<21)}\\
{\footnotesize\tt ~~~~~\{}\\
{\footnotesize\tt ~~~~~~z~=~z**2~+~zi}\\
{\footnotesize\tt ~~~~~~iter=iter+1}\\
{\footnotesize\tt ~~~~~\}}\\
{\footnotesize\tt ~~~~if~~~~~~(iter~<~~1)~\{~;~linebuffer~="\%s~"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~~2)~\{~;~linebuffer~="\%s."\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~~4)~\{~;~linebuffer~="\%s-"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~if~(iter~<~20)~\{~;~linebuffer~="\%s*"\%(linebuffer)~;~\}~$\backslash$}\\
{\footnotesize\tt ~~~~else~~~~~~~~~~~~~~~~\{~;~linebuffer~="\%s\&"\%(linebuffer)~;~\}}\\
{\footnotesize\tt ~~~\}}\\
{\footnotesize\tt ~~print~linebuffer}\\
{\footnotesize\tt ~\}} \vspace{0.5cm}\\

The output of this script is as follows: \\

{\tt |~~~~~~~~~~~~~~~~~....................~~~~~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~............................~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~..................................~~~~~~~~~~}\newline
{\tt |~~~~~~~~......................................~~~~~~~~}\newline
{\tt |~~~~~~........-------------.....................~~~~~~}\newline
{\tt |~~~~~....--------------****-----.................~~~~~}\newline
{\tt |~~~~..----------------*******------................~~~}\newline
{\tt |~~~.---------------*****\&\&\&****------...............~~}\newline
{\tt |~~.-------------***\&***\&\&\&\&\&*****-----..............~~}\newline
{\tt |~.---------********\&\&\&\&\&\&\&\&\&\&\&\&\&**-----..............~}\newline
{\tt |~------**********\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&*------.............~}\newline
{\tt |~----******\&\&\&\&\&*\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&*------..............}\newline
{\tt |~********\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~---*****\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~-----*****\&\&\&\&\&*\&\&\&\&\&\&\&\&\&\&\&\&\&\&\&**------..............}\newline
{\tt |~-------***********\&\&\&\&\&\&\&\&\&\&\&\&\&**------.............~}\newline
{\tt |~~----------*******\&\&\&\&\&\&\&\&\&\&\&\&\&**-----..............~}\newline
{\tt |~~.--------------*******\&\&\&******-----..............~~}\newline
{\tt |~~~..---------------*****\&****------...............~~~}\newline
{\tt |~~~~...---------------******------................~~~~}\newline
{\tt |~~~~~.....---------------------..................~~~~~}\newline
{\tt |~~~~~~~..........-------.......................~~~~~~~}\newline
{\tt |~~~~~~~~~.....................................~~~~~~~~}\newline
{\tt |~~~~~~~~~~~................................~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~~..........................~~~~~~~~~~~~~~}\newline
{\tt |~~~~~~~~~~~~~~~~~~~................~~~~~~~~~~~~~~~~~~~}\\
}

\section{The \indcmdt{exec}}

The \indcmdt{exec} can be used to execute PyXPlot commands contained within
string variables. For example:

\begin{verbatim}
terminal="eps"
exec "set terminal %s"%(terminal)
\end{verbatim}

It can also be used to write obfuscated PyXPlot scripts.

\section{Shell Commands}

Shell commands\index{shell commands!executing} may be executed directly from
within PyXPlot by prefixing them with an \indcmdts{!} character. The
remainder of the line is sent directly to the shell, for example:

\begin{verbatim}
!ls -l
\end{verbatim}

\noindent Semi-colons cannot be used to place further PyXPlot commands after a
shell command on the same line.

\begin{dontdo}
!ls -l ; set key top left
\end{dontdo}

It is also possible to substitute the output of a shell command into a PyXPlot
command. To do this, the shell command should be enclosed in back-quotes (`).
For example:\index{backquote character}\index{shell commands!substituting}

\begin{verbatim}
a=`ls -l *.ppl | wc -l`
print "The current directory contains %d PyXPlot scripts."%(a)
\end{verbatim}

It should be noted that back-quotes can only be used outside quotes. For
example:

\begin{dontdo}
set xlabel '`ls`'
\end{dontdo}

\noindent will not work. The best way to do this would be:

\begin{dodo}
set xlabel `echo "'" ; ls ; echo "'"`
\end{dodo}

Note that it is not possible to change the current working directory by sending
the {\tt cd} command to a shell, as this command would only change the working
directory of the shell in which the single command is executed:

\begin{dontdo}
!cd ..
\end{dontdo}

PyXPlot has its own \indcmdt{cd} for this purpose, as well as its own
\indcmdt{pwd}:

\begin{dodo}
cd ..
\end{dodo}

\section{Script Watching: pyxplot\_watch}

PyXPlot includes a simple tool for watching command script files and executing
them whenever they are modified. This may be useful when developing a command
script, if one wants to make small modifications to it and see the results in a
semi-live fashion. This tool is invoked by calling the {\tt
pyxplot\_watch}\index{pyxplot\_watch}\index{watching scripts} command from a
shell prompt. The command-line syntax of {\tt pyxplot\_watch} is similar to
that of PyXPlot itself, for example:

\begin{verbatim}
pyxplot_watch script.ppl
\end{verbatim}

\noindent would set {\tt pyxplot\_watch} to watch the command script file
{\tt script.ppl}. One difference, however, is that if multiple script files are
specified on the command line, they are watched and executed independently,
\textit{not} sequentially, as PyXPlot itself would do. Wildcard characters can
also be used to set {\tt pyxplot\_watch} to watch multiple
files.\footnote{Note that {\tt pyxplot\_watch *.script} and
{\tt pyxplot\_watch $\backslash$*.script} will behave differently in most
UNIX shells.  In the first case, the wildcard is expanded by your shell, and a
list of files passed to {\tt pyxplot\_watch}. Any files matching the
wildcard, created after running {\tt pyxplot\_watch}, will not be picked up.
In the latter case, the wildcard is expanded by {\tt pyxplot\_watch} itself,
which {\it will} pick up any newly created files.}

This is especially useful when combined with \ghostview's\index{Ghostview}
watch facility. For example, suppose that a script {\tt foo.ppl} produces
postscript output {\tt foo.ps}. The following two commands could be used to
give a live view of the result of executing this script:

\begin{verbatim}
gv --watch foo.ps &
pyxplot_watch foo.ppl
\end{verbatim}

