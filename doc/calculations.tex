% CALCULATIONS.TEX
%
% The documentation in this file is part of PyXPlot
% <http://www.pyxplot.org.uk>
%
% Copyright (C) 2006-2010 Dominic Ford <coders@pyxplot.org.uk>
%               2009-2010 Ross Church
%
% $Id$
%
% PyXPlot is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% You should have received a copy of the GNU General Public License along with
% PyXPlot; if not, write to the Free Software Foundation, Inc., 51 Franklin
% Street, Fifth Floor, Boston, MA  02110-1301, USA

% ----------------------------------------------------------------------------

% LaTeX source for the PyXPlot Users' Guide

\chapter{Performing Calculations}

The previous chapter described how PyXPlot can be used to plot data directly
from \datafile s onto graphs. Often, however, calculations need to be performed
on data before it is plotted, and so in this chapter we show the mathematical
environment which PyXPlot provides for manipulating and perform calculationing
on data.  For simplicity, throughout this chapter we perform single
calculations on the values of variables, displaying the results using the {\tt
print} command, essentially using PyXPlot as a desktop calculator; we will show
in subsequent chapters examples of the use of this mathematical environment in
producing plots.

\section{Variables}

Variables can be assigned to hold numerical values using syntax of the form:

\begin{verbatim}
a = 5.2 * sqrt(64)
\end{verbatim}

\noindent which may optionally be written as:\indcmd{let}

\begin{verbatim}
let a = 5.2 * sqrt(64)
\end{verbatim}

\noindent Numerical variables can subsequently be used by name in mathematical
expressions, as in the example:

\begin{verbatim}
print a / sqrt(64)
\end{verbatim}

\noindent A variable can subsequently be undefined to have no value using
syntax of the form:

\begin{verbatim}
a=
\end{verbatim}

A list of all variables which are currently defined can be obtained by typing
{\tt show variables}\indcmd{show variables}. By default quite an extensive list
is returned, as many physical constants are defined by default in PyXPlot. In
Section~\ref{sect:stringvars}, we will see that variables can also be set to
hold string values -- i.e.\ to hold pieces of text -- and that such variables
can have great power in allowing the user to autogenerate titles and labels for
graphs.

\section{Physical Constants}
\label{sec:constants}
\index{physical constants}\index{constants}

A wide range of mathematical and physical constants are defined by default in
PyXPlot. A complete list can be obtained by typing {\tt show variables} or by
consulting Chapter~\ref{ch:constants}. Some of these, for example, {\tt e},
{\tt pi} and {\tt GoldenRatio} are standard mathematical constants, the last of
these being the default aspect ratio of plots produced by PyXPlot. Many of the
others are physical constants, which are prefixed with {\tt phy\_} to minimise
clashes between their names and those of variables which the user may wish to
define.  Nonetheless, pre-defined constants are no different from any other
variables in PyXPlot, and the user can freely redefine them without this being
an error.

Most of the pre-defined physical constants are not dimensionless quantities,
and make use of PyXPlot's native ability to keep track of the physical units of
quantities and to convert between different unit systems -- for example,
between inchs and centimetres.  This will be explained in more detail in
Section~\ref{sec:units}.

\section{Functions}

A large number of standard functions are pre-defined within PyXPlot's
mathematical environment, ranging from trigonometric functions, to very
specialised functions, for example to evaluate the phase of the Moon on any
given day or the size of the Universe in the $\Uplambda_\mathrm{CDM}$
cosmological model. A complete list of these can be obtained by typing {\tt
show functions}\indcmd{show functions}, or by consulting
Chapter~\ref{ch:function_list}. In addition, the user can define his own
functions using a similar syntax to that used to declare new variables, as in
the examples:

\begin{verbatim}
f()~~~~= pi
f(x)~~~= x*sin(x)
f(x,y)~= x*y
\end{verbatim}

A list of all of the user-defined functions which have been set can be found at
the end of the output of the \indcmdt{show functions}, or can be obtained
without the list of system-defined functions by typing {\tt show
userfunctions}\indcmd{show userfunctions}. Unlike in the case of pre-defined
variables, system-defined functions may not be over-written; trying to define a
function with the name {\tt sin(x)}, for example, will result in an error.

Once defined, user-defined functions can be undefined by typing, for example:

\begin{verbatim}
f()~=
\end{verbatim}

Where the logic required to define a particular function is greater than can be
contained in a single algebraic expression, a subroutine should be used (see
Section~\ref{sec:subroutines}); these allow an arbitrary numbers of PyXPlot
code to be executed whenever a function is evaluated.

\subsection{Spliced Functions}
\index{function splicing}
\index{splicing functions}

Functions can be given definitions which are declared to be valid only within a
certain range of argument space, or given multiple definitions which are valid
in different parts of argument space. We term this {\it function splicing},
since multiple algebraic definitions of a functions are being spliced at the
boundaries between the variouss regimes.  The following example would define a
function which is only valid within the range $-2<x<2$:\footnote{The syntax
{\tt [-2:2]} can also be written {\tt [-2 to 2]}.}

\begin{verbatim}
f(x)[-pi/2:pi/2] = cos(x)
\end{verbatim}

\noindent Attempts to evaluate this function outside of the range in which it
was defined would return an error, that the function is not defined at the
requested ordinate value. So, if the above function were to be plotted, no line
would be drawn outside of the range $-\nicefrac{\pi}{2}<x<\nicefrac{\pi}{2}$. A
similar effect could also have been acheieved using the {\tt select} keyword;
see Section~\ref{sec:select_modifier}. Commonly, however, the desired behaviour
is rather that the function should be zero outside of some region of parameter
space where it has a finite value. This can be achieved as in the following
example:

\begin{verbatim}
f(x) = 0
f(x)[-pi/2:pi/2] = cos(x)
\end{verbatim}

\noindent Plotting this function would yield the result:

\begin{center}
\includegraphics[width=8cm]{examples/eps/ex_intro_func_splice.eps}
\end{center}

\noindent In this example, we have made use of the fact that if there is an
overlap in the valid argument space for multiple definitions, then later
declarations take precedence. The definition that the function equals zero is
valid everywhere, but is overridden in the region
$-\nicefrac{\pi}{2}<x<\nicefrac{\pi}{2}$ by the second function definition.

Where functions have been spliced together, the {\tt show functions} command
will show all of the definitions of the spliced function, together with the
regions of parameter space in which they are used. This is indicated using the
same syntax as is used for defining spliced functions, such that the output can
be stored and pasted into a future PyXPlot session to redefine exactly the same
spliced function.

When a function takes more than one argument, multiple ranges can be specified,
one for each argument. Any of the limits can be left blank if there is no
upper- or lower-limit upon the value of a particular argument. In the following
example, the function {\tt f(a,b,c)} would only be defined when all of {\tt a},
{\tt b} and {\tt c} were in the range $-1 \to 1$:

\begin{verbatim}
f(a,b,c)[-1:1][-1:1][-1:1] = a+b+c
\end{verbatim}

Function splicing can be used to define functions which do not have analytic
forms, or which are, by definition, discontinuous, such as top-hat functions or
Heaviside functions. The following example would define $f(x)$ to be a
Heaviside function:

\begin{verbatim}
f(x) = 0
f(x)[0:] = 1
\end{verbatim}

\example{ex:funcsplice2}{Modelling a physics problem using a spliced function}{
In this example we use a spliced function to model a simple physics problem.  A
light bead is free to move from side to side between two walls which are placed
at $x=-2l$ and $x=2l$. It is connected to each wall by a light elastic string
of natural length $l$, which applies a force $k\Updelta x$ when extended by an
amount $\Updelta x$, but which applies no force when slack. What is the force
on the bead as a function of its horizontal position $x$?
\nlnp
This system has three distinct regimes. In the region $-l<x<l$, both strings
are under tension. When $x<-l$, the left-hand string is slack, and only the
right-hand string exerts a force. When $x>l$, the converse is true: only the
left-hand string exerts a force. The case $|x|>2l$ is not possible, as the bead
would be penetrate the hard walls. It is left as an exercise for the reader to
use Hooke's Law to solve this problem, but in summary, the force on the bead
can be defined in PyXPlot using the expressions:
\nlscf
\noindent {\tt F(x)[-2*l~:-~~l]~= -k*(x+l)}\newline
\noindent {\tt F(x)[-~~l~:~~~l]~= -2*k*x}\newline
\noindent {\tt F(x)[~~~l~:~2*l]~= -k*(x+l)}
\nlfcf
where it is necessary to first define a value for {\tt l} and {\tt k}. Plotting
these functions yields the result:
\nlscf
\begin{center}
\includegraphics[width=\textwidth]{examples/eps/ex_funcsplice2.eps}
\end{center}
\nlscf
Attempting to plot this function with an $x$-axis which extends outside of the
range of values of $x$ for which $F(x)$ is defined will result in error
messages being returned that the function could not be evaluated at all
ordinate values. These can be suppressed by typing (see
Section~\ref{sec:num_errs}):
\newline\noindent {\tt set numeric errors quiet}
}

\example{ex:funcsplice}{Using a spliced function to calculate the Fibonacci numbers}{
The Fibonacci numbers are defined to be the sequence of numbers in which each
member is the sum of its two immediate predecessors, and the first three
members of the sequence are ${0,1,1}$. Thus, the sequence runs
${0,1,1,2,3,5,8,13,21,34,55,...}$. In this example, we use of function splicing
to calculate the Fibonacci sequence in an iterative and highly inefficient way,
by hard-coding the first three members of the sequence, and then using the
knowledge that all of the subsequent members of the sequence are the sums of
their two immediate predecessors:
\nlscf
\noindent {\tt f(x)     = 0.0}\newline
\noindent {\tt f(x)[1:] = 1.0}\newline
\noindent {\tt f(x)[3:] = f(x-1) + f(x-2)}
\nlfcf
This method is highly inefficient because each evaluation spawns two further
evaluations of the function, and so the number of operations required to
evaluated {\tt f(x)} scales as $2^x$.  It is inadvisable to evaluate it for
$x\gtrsim25$ unless you're prepared for a long wait.
\nlnp
A much more efficient method of calculating the Fibonacci numbers is to use Binet's formula,
\begin{displaymath}
f(x) = {\psi^x - (1-\psi)^x}{\sqrt{5}},
\end{displaymath}
where $\psi=1+\sqrt{5}/2$ is the golden ratio, which provides an analytic
expression for the sequence.  In the following script, we compare the values
returned by these two implementations. We enable complex arithmetic as Binet's
formula returns complex numbers for non-integer values of $x$.
\nlscf
\noindent {\tt f(x)~~~~~= 0.0}\newline
\noindent {\tt f(x)[1:]~= 1.0}\newline
\noindent {\tt f(x)[3:]~= f(x-1) + f(x-2)}\newline
\\
\noindent {\tt \# Binet's Formula for the Fibonacci numbers}\newline
\noindent {\tt set numerics complex}\newline
\noindent {\tt binet(x) = Re((GoldenRatio**x - (1-GoldenRatio)**x) / sqrt(5))}\newline
\\
\noindent {\tt set samples 100}\newline
\noindent {\tt set xrange [0:9.5]}\newline
\noindent {\tt set yrange [0:35]}\newline
\noindent {\tt set xlabel "\$x\$"}\newline
\noindent {\tt set ylabel "\$y\$"}\newline
\noindent {\tt set key bottom right}\newline
\noindent {\tt plot f(x) , binet(x)}
\nlscf
\begin{center}
\includegraphics[width=\textwidth]{examples/eps/ex_funcsplice.eps}
\end{center}
}

\section{Handling Numerical Errors}
\label{sec:num_errs}
\index{numerical errors}

By default, an error message is returned whenever calculations return values
which are infinite, as in the case of {\tt 1/0}, or when functions are
evaluated outside the range of parameter space in which they are defined, as in
the case of {\tt besseli(-1,1)}.  Sometimes this behaviour is desirable: it
flags up to the user that a calculation has gone wrong, and exactly what the
problem is.  At other times, however, these error messages can be undesirable
and may lead you to miss more genuine and serious errors buried in their midst.

For this reason, the issuing of explicit error messages when calculations
return non-finite numeric results can be switched off by typing
\indcmd{set numeric errors quiet}

\begin{verbatim}
set numeric errors quiet
\end{verbatim}

\noindent Having done this, expressions such as

\begin{verbatim}
x = besseli(-1,1)
\end{verbatim}

\noindent fail silently, and variables which contain non-finite numeric results
are displayed as {\tt NaN}\index{NaN}, which stands for {\it Not a
Number}\index{not a number}.

The issuing of explicit errors may subsequently be re-enabled by typing
\indcmd{set numeric errors explicit}

\begin{verbatim}
set numeric errors explicit
\end{verbatim}

\section{Working with Complex Numbers}
\label{sec:complex_numbers}
\index{complex numbers}

In all of the examples given thus far, algebraic expressions have only been
allowed to return real numbers: PyXPlot has not been handling any complex
numbers. Since there are many circumstances in which you may be analysing data
which you are certain is real, complex arithmetic is disabled by default.
Expressions such as {\tt sqrt(-1)} will return either an error or {\tt NaN}.
The most obvious example of this is the built-in variable {\tt i}, which is set
to equal {\tt sqrt(-1)}:

\begin{verbatim}
pyxplot> print i
nan
\end{verbatim}

Complex arithmetic may be enabled by typing
\indcmd{set numeric complex}

\begin{verbatim}
set numeric complex
\end{verbatim}

\noindent and then disabled again by typing
\indcmd{set numeric real}

\begin{verbatim}
set numeric real
\end{verbatim}

Once complex arithmetic is enabled, many of PyXPlot's built in mathematical
functions accept complex input arguments, including the logarithm function, all
of the trigonometric functions, and the exponential function.  A complete list
of functions which accept complex inputs can be found in
Appendix~\ref{ch:function_list}.

Complex number literals can be entered into algebraic expressions in either of
the following two forms:

\begin{verbatim}
print (2 + 3*i       )
print (2 + 3*sqrt(-1))
\end{verbatim}

\noindent The former version depends upon the pre-defined system variable {\tt
i} being defined to equal $\sqrt{-1}$. The user could cause this to stop working,
of course, by re-defining this variable to have a different value.  However, in
this case the variable {\tt i} could straightforwardly be returned to its
default value by typing:

\begin{verbatim}
i=sqrt(-1)
\end{verbatim}

\noindent The user can, of course, define any other variable to equal
$\sqrt{-1}$, thus allowing him to use any other letter, e.g.\ {\tt j}, to
represent the imaginary component of a number.

Several built-in functions are provided for performing manipulations on complex
numbers. the \indfunt{Re(z)} and \indfunt{Im(z)} functions return respectively
the real and imaginary parts of a complex number $z$, the \indfunt{arg(z)}
function returns the complex argument of $z$, and the \indfunt{abs(z)} function
returns the modulus of $z$.  The \indfunt{conjugate(z)} command returns the
complex conjugate of $z$. The following lines of code demonstrate the use of
these functions:

\begin{verbatim}
set numeric complex
x=0.5
print Re(exp(i*x))
print cos(x)        # This equals the above
print arg(exp(i*x)) # This equals x
\end{verbatim}

\section{Working with Physical Units}
\label{sec:units}
\index{physical units}\index{units}

PyXPlot has extensive facilities for handling data with a range of physical
units.  These features also make it a powerful desktop tool for converting
quantities between different imperial and metric units, and for doing simple
back-of-the-envelope calculations where numbers are substituted into equations
and you want to know what the dimensions of the quantity you've calculated are.

All numeric variables in PyXPlot have not only a magnitude, but also a
physical unit associated with them. In the case a pure number such as~2, the
quantity is said to be dimensionless: it has no physical unit. The special
function \indfunt{unit()} is used to specify the physical unit associated with a
quantity. For example, the expression

\begin{verbatim}
print 2*unit(s)
\end{verbatim}

\noindent takes the number~2 and multiplies it by the unit {\tt s}, which is
the SI abbreviation for seconds.  The resulting quantity then has dimensions of
time, and could, for example, be divided by the unit {\tt hr} to find the
dimensionless number of hours in two seconds:

\begin{verbatim}
print 2*unit(s)/unit(hr)
\end{verbatim}

\boxout{A note on the use of the radian is a base unit in PyXPlot.}{box:angles}{
\index{units!angle}\index{angles, handling of}
By convention, the SI system of units does not have a base unit of angle:
instead, the radian is considered to be a dimensionless unit.  There are some
strong mathematical reasons why this makes sense, since it makes it possible to
write equations such as
\begin{displaymath}
d=\theta r
\end{displaymath}
and
\begin{displaymath}
x = \exp(a+i\theta).
\end{displaymath}
However, it also has some disadvantages: some interesting quantities are
measured per unit angle or per unit solid angle, and the SI system offers no
way to dimensionally distinguish these from one another or from quantities with
no angular dependence.

On balance, we have decided that it is more useful if PyXPlot {\it does}
consider the radian to be a base unit, so that it can understand quantities
such as radiative fluxes measured per steradian. The unfortunate consequence of
this is that first equation above to be rewritten as:
\begin{displaymath}
d=\left(\frac{\theta}{2\pi\,\mathrm{rad}}\right) r
\end{displaymath}

As compensation, the $\exp()$ function and all of the trigonometric functions
accept either quantities with dimensions of angles, or dimensionless numbers as
inputs. The second equation above might need some modification, however, since
it is not possible to add a dimensionless number to an angle.
}

Compound units such as miles per hour, which is defined in terms of two other
units, can be used thus

\begin{verbatim}
print 2*unit(miles/hour)
\end{verbatim}

\noindent or, in many cases, have their own explicit abbreviations, in this
case {\tt mph}:

\begin{verbatim}
print 2*unit(mph)
\end{verbatim}

\noindent As these examples demonstrate, the {\tt unit()} function can be
passed a string of units either multiplied together with the {\tt *} operator,
or divided using the {\tt /} operator. Units may be raised to powers with the
{\tt **} operator\footnote{The {\tt \^{}} character may be used as an alias for
the {\tt **} operator, though this notation is arguably confusing, since the
same character is used for the binary exclusive or operator in PyXPlot's normal
arithmetic.}, as in

\begin{verbatim}
a = 2*unit(m**2)
print "An area of %f square feet"%(a/unit(ft**2))
\end{verbatim}

\noindent As these examples also demonstrate, units may be refered to either by
their abbreviated or full names, and either in their singular or plural forms.
A complete list of all of the units which PyXPlot recognises by default,
together with all of their recognised names can be found in
Appendix~\ref{ch:unit_list}.

SI units may also be preceded with SI prefixes\index{units!SI prefixes}, for
example:

\begin{verbatim}
a = 2*unit(um)
a = 2*unit(micrometres)
\end{verbatim}

When quantities with physical units are substituted into algebraic expressions,
PyXPlot automatically checks that the expression is dimensionally correct
before evaluating it. For example, the following expression is not
dimensionally correct and would return an error because the first term in the
sum has dimensions of velocity, meanwhile the second term is a length:
\index{units!dimensional analysis}

\begin{verbatim}
a = 2*unit(m)
b = 4*unit(s)
print a/b + a
\end{verbatim}

\noindent PyXPlot continues to throw an error in this case, even when explicit
numerical errors are turned off with the \indcmdt{set numeric errors quiet},
since it is deemed a serious error: the above expression would never be correct
for any values of {\tt a} and {\tt b} given their dimensions.

As a quick perusal of Appendix~\ref{ch:unit_list} will show, a large number of
units are pre-defined in PyXPlot by default. However, the need may occasionally
arise to define new units. It is not possible to do this from an interactive
PyXPlot terminal, but it is possible to do so from a configuration script which
PyXPlot runs upon start-up. This will be discussed in
Chapter~\ref{ch:configuration}, where we shall also see that new base units can
also be defined. Just as the Pluto mass can be defined as a new measure of
mass, so the potato can be defined as a new measure of number of vegetables.

\subsection{Converting between different Temperature Scales}
\index{temperature conversions}\index{units!temperature}

PyXPlot's facilities for converting quantities between different physical units
include the ability to convert temperatures between different temperature
scales, for example, between $^\circ\mathrm{C}$, $^\circ\mathrm{F}$ and K.
However, these conversions have some subtleties, unique to temperature
conversions, which mean that they should be used with some caution. Consider
the following two questions:
\begin{itemize}
\item How many degrees Kelvin corresponds to a temperature of $20^\circ$C?
\item How many degrees Kelvin corresponds to a temperature {\it rise} of $20^\circ$C?
\end{itemize}
The answers to these two questions are 293\,K and 20\,K respectively: we see
that although we are converting from $20^\circ$C in both cases, the
corresponding number of Kelvin depends upon whether we are talking about an
{\it absolute} temperature or a {\it relative} temperature. A heat capacity of
1\,J/$^\circ$C equals 1\,J/K, even though $1^\circ$C does not equal 1\,K.

The cause of this problem, and the reason why it rarely affects any physical
units other than temperatures is that there exists such a thing as absolute
temperature. Distances, for example, are very rarely absolute: they measure
relative distance gaps between points. Occasionally people might choose to
express all their displacements relative to a particular origin, but they
wouldn't expect PyXPlot to be able to convert these into displacements from
another origin. But they might expect it to be able to convert temperatures
between Celsius and Fahrenheit, even though the problem of doing so is
equivalent.

Times are occasionally expressed as absolute quantities: the year 1453, for
example, implicitly corresponds to 1453 years since the Christian epoch.
Similar problems would arise in trying to convert such a year into the Muslim
calendar, which counts from the year {\footnotesize AD} 622, to those of
encountered in converting between temperature scales.\footnote{PyXPlot can,
incidentally, make this conversion, as will be seen in
Section~\ref{sec:time_series}.}

As PyXPlot cannot distinguish between absolute and relative temperatures, it
takes a safe approach of performing algebra consistently with any unit of
temperature, never performing automatic conversions between different
temperature scales. A calculation based on temperatures measured in
$^\circ\mathrm{F}$ will produce an answer measured in $^\circ\mathrm{F}$.
However, as converting temperatures between temperature scales is a useful task
which is often wanted, this is allowed, when specifically requested, in the
specific case of dividing one temperature by another unit of temperature to get
a dimensionless number, as in the following example:

\begin{dodo}
print 98*unit(oF) / unit(oC)
\end{dodo}

\noindent Note that the two units of temperature must be placed in separate
{\tt unit(...)} functions. The following is not allowed:

\begin{dontdo}
print 98*unit(oF / oC)
\end{dontdo}

Note that such a conversion always assumes that the temperatures supplied are
{\it absolute} temperatures. PyXPlot has no facility for converting relative
temperatures between different scales. This must be done manually.

The conversion of derived units of temperature, such as $\mathrm{J}/\mathrm{K}$ or
$^\circ\mathrm{C}^2$, to derived units of other temperature scales, such as
$\mathrm{J}/^\circ\mathrm{F}$ or $\mathrm{K}^2$, is not permitted, since in
general these conversions are ill-defined. For example, a temperature squared
measured in $^\circ\mathrm{C}^2$ has the same value for $\pm
x^\circ\mathrm{C}$, but would have different values in $\mathrm{K}^2$.

The moral of this story is: pick what unit of temperature you want to work in,
convert all of your temperatures to that scale, and then stick to it.

\example{ex:temperature}{Creating a simple temperature conversion scale}{
In this example, we use PyXPlot's automatic conversion of physical units to
create a temperature conversion scale.
\nlscf
\begin{center}
\includegraphics{examples/eps/ex_tempscale.eps}
\end{center}
}

\section{Configuring how Numbers are Displayed}
\label{sec:unitdisp}

\subsection{Units}

By default, when a number which has physical dimensions is displayed PyXPlot
searches through its database of physical units for the most appropriate unit
in which to represent it. The name of the adopted unit is printed after the
value. By default, quantities are displayed by preference in SI units, and SI
prefixes such as milli- or kilo- are applied where appropriate. All of the
behaviour, however, can be configured.

PyXPlot has a number of different {\it units schemes}\index{units!unit
schemes}, each of which comprises a list of units which are to be used in
preference to all others. For example, in the CGS unit scheme\index{CGS
units}\index{units!CGS}, all lengths are displayed in centimetres, all masses
are displayed in grammes, and so forth. In the imperial unit
scheme\index{imperial units}\index{units!imperial}, quantities are displayed in
British imperial units, meanwhile in the US unit scheme, US customary units are
used. The current unit scheme can be changed using the \indcmdt{set unit
scheme}:

\begin{verbatim}
pyxplot> vol = 3*unit(m**3)
pyxplot> set unit scheme si ; print vol
3 cubic_m
pyxplot> set unit scheme cgs ; print vol
3000000 cubic_cm
pyxplot> set unit scheme imperial ; print vol
82.488468 bushels_(UK)
pyxplot> set unit scheme us ; print vol
85.13278 bushels_(US)
\end{verbatim}

\noindent A complete list of PyXPlot's unit schemes can be found in
Table~\ref{tab:unit_schemes}.\index{natural units}\index{units!natural}

\begin{table}
\framebox[\textwidth]{
\begin{tabular}{lp{9cm}}
{\bf Name} & {\bf Description} \\
\hline
{\tt ancient} & Ancient units, especially those used in the Authorised Version of the Bible. \\
{\tt CGS} & CGS units. \\
{\tt Imperial} & British imperial units. \\
{\tt Planck} & Planck units, also known as natural units, which make several physical constants equal unity. \\
{\tt SI} & SI units. \\
{\tt US} & US customary units. \\
\hline
\end{tabular}}
\caption{A list of PyXPlot's unit schemes.}
\label{tab:unit_schemes}
\end{table}

In some cases, one may want to broadly use one of these unit schemes, but
override one of the units in favour of another.  Astronomers, for example, may
wish to use SI or CGS units to express all quantities with the exception of
distances, which they wish to express in parsecs or astronomical units. Another
astronomer might wish to express masses in solar or Jupiter masses, or
luminosities in solar luminosities. This level of control is made available
through the \indcmdt{set unit of} command, for example:

\begin{verbatim}
set unit of length parsec
set unit of mass Mjupiter
\end{verbatim}

The more unusual case of the astronomer who wishes to express masses in Pluto
masses is more complicated: the Pluto mass is not a pre-defined unit in
PyXPlot, and it must first be defined before it can be set as a default unit.
In Chapter~\ref{ch:configuration}, we shall see how to define new units in a
configuration script.

By default, units are displayed in their abbreviated forms, for example {\tt A} for amperes, and SI prefixes such as milli- and kilo- are applied to SI units where they are appropriate.\index{SI prefixes}\index{units!SI prefixes} In both cases, this behaviour
can be turned on or off, in the former case with the commands:

\begin{verbatim}
set unit display abbreviated
set unit display full
\end{verbatim}

\noindent and in the latter case using the following pair of commands:

\begin{verbatim}
set unit display prefix
set unit display noprefix
\end{verbatim}

\subsection{Changing the Accuracy to which Numbers are Displayed}

By default, when a number is displayed, it is printed accurate to eight
significant figures, although fewer figures may actually be displayed if the
final digits are zeros or nines.

This is generally a helpful convention: PyXPlot's internal arithmetic is
generally accurate to around 16 significant figures, and so it is quite
conceivable that a calculation which is supposed to return, say $1$, may in
fact return 0.999\,999\,999\,999\,999\,9. Likewise, when complex arithmetic is
enabled, routines which are expected to return real numbers may in fact return
results with imaginary parts at the level of one part in $10^{16}$.  By
displaying numbers to only eight significant figures in such cases, the user is
usually shown the `right' answer, instead of a noisy and unattractive one.

However, there may also be cases where more accuracy is desirable, in which
case, the number of significant figures to which output is displayed can be set
using the command\indcmd{set numerics sigfig}

\begin{verbatim}
n = 12
set numerics sigfig n
\end{verbatim}

\noindent where {\tt n} can be any number in the range 1-30. It should be noted
that the number supplied is the {\it minimum} number of significant figures to
which numbers are displayed; on occasion an extra figure may be displayed.

Alternatively, the string substitution operator, described in
Section~\ref{sec:string_subs_op} may be used to specify how a number should be
displayed on a one-by-one basis, for example:

\begin{verbatim}
print "%d"  %(pi) # Print the integer part of pi
print "%.5f"%(pi) # Print pi in non-scientific format, to
                  #   5 decimal places
print "%.5e"%(pi) # Print pi in scientific format, to
                  #   5 decimal places
print "%s"  %(pi) # Print pi as normal
\end{verbatim}

\subsection{Creating Pastable Text}
\label{sec:pastable}

PyXPlot's default convention of displaying numbers in a format such as

\begin{verbatim}
(2+3i) metres
\end{verbatim}

\noindent is well-suited for creating text which is readable by human users, but
is less well-suited for creating text which can be copied and pasted into
another calculation in another PyXPlot terminal, or for creating text which
could be used in a \LaTeX\ text label on a plot. For this reason, the
\indcmdt{set numerics display} command allows the user to choose between three
different ways in which numbers can be displayed:

\begin{verbatim}
pyxplot> set numerics display natural
pyxplot> print phy_c
299792 km/s
pyxplot> set numerics display typeable
pyxplot> print phy_c
299792*unit(km/s)
pyxplot> set numerics display latex
pyxplot> print phy_c
$299792\,\mathrm{km}/\mathrm{s}$
\end{verbatim}

The first case is the default way in which PyXPlot displays numbers. The second
case produces text which forms a valid algebraic expression which could be
pasted into another PyXPlot calculation. The final case produces a string of
\LaTeX\ text which could be used as a label on a plot.

\section{Numerical Integration and Differentiation}

\index{differentiation}\index{integration} Two special functions,
\indfunt{int\_dx()} and \indfunt{diff\_dx()}, may be used to numerically
integrate or differentiate an algebraic expressions.  In each case, the letter
{\tt x} is the dummy variable which is to be used in the integration or
differentiation, and may be replaced by any valid variable name of up to
16~characters in length.

The function {\tt int\_dx()} takes three parameters -- firstly the expression
to be integrated, which may optionally be placed in quotes, followed by the
minimum and maximum integration limits. These may have any physical dimensions,
so long as they match, but must both be real numbers. For example, the
following would plot the integral of the function $\sin(x)$:

\begin{verbatim}
plot int_dt('sin(t)',0,x)
\end{verbatim} 

The function {\tt diff\_dx()} takes two obligatory parameters plus one further
optional parameters. The first is the expression to be differentiated, which,
as above, may optionally placed in quotes for clarity. This should be followed
by the numerical value of the dummy variable at the point where the given
expression is to be differentiated. This value may have any physical
dimensions, and may be a complex number if complex arithmetic is enabled. The
final, optional, parameter to the {\tt diff\_dx()} function is an approximate
step size which indicates the range of argument values over which PyXPlot
should take samples to determine the gradient. If no value is supplied, a value
of $10^{-6}$ is used.  The following example would evaluate the differential of
the function $\cos(x)$ with respect to $x$ at $x=1.0$:

\begin{dodo}
print diff\_dx('cos(x)', 1.0)
\end{dodo}

When complex arithmetic is enabled, PyXPlot checks that the function being
differentiated satisfies the Cauchy-Riemann equations, and returns an error if
it does not to indicate that it is not differentiable.  The following is an
example of a function which is not differentiable, and which throws an error
because the Cauchy-Riemann equations are not satisfied:

\begin{dontdo}
set num comp\newline
print diff\_dx(Re(sin(x)),1)
\end{dontdo}

Advanced users may be interested to know that \indfunt{int\_dx()} function is
implemented using the {\tt gsl\_integration\_qags()} function of the Gnu
Scientific Library\index{GSL}, and the \indfunt{diff\_dx()} function is
implemented using the {\tt gsl\_deriv\_central()} function of the same library.
Any caveats which apply to the use of these routines also apply to PyXPlot's
numerical calculus routines.

\example{ex:calculus}{An example}{
In this example,.
}

\section{Solving Systems of Equations}

The \indcmdt{solve} can be used to solve simple systems of one or more
equations numerically. It takes as its arguments a comma-separated list of the
equations which are to be solved, and a comma-separated list of the variables
which are to be solved for. The latter should be prefixed by the word {\tt
via}, to separate it from the list of equations:

\begin{verbatim}
solve <equation 1>,... via <variable 1>, ...
\end{verbatim}

Note that the time taken by the solver dramatically increases with the number
of variables which are simultaneously solved for, meanwhile the accuracy
achieved simultaneously decreases. The following example solves a simple pair
of simultaneous equations of two variables:

\begin{verbatim}
pyxplot> solve x+y=10, x-y=3 via x,y
pyxplot> print x
6.5
pyxplot> print y
3.5
\end{verbatim}

\noindent No output is returned to the terminal if the numerical solver
succeeds, otherwise an error message is displayed. If any of the fitting
variables are already defined prior to the \indcmdt{solve} being called, their
values are used as initial guesses, otherwise an initial guess of unity for
each fitting variable is assumed. Thus, the same \indcmdt{solve} returns two
different values in the following two cases:

\begin{verbatim}
pyxplot> x= # Undefine x
pyxplot> solve cos(x)=0 via x
pyxplot> print x/pi
0.5
pyxplot> x=10
pyxplot> solve cos(x)=0 via x
pyxplot> print x/pi
3.5
\end{verbatim}

\noindent In cases where any of the variables being solved for are not
dimensionless, it is essential that an initial guess with appropriate units be
supplied, otherwise the solver will try and fail to solve the system of
equations using dimensionless values:

\begin{dontdo}
x =\newline
y = 5*unit(km)\newline
solve x=y via x
\end{dontdo}

\begin{dodo}
x = unit(m)\newline
y = 5*unit(km)\newline
solve x=y via x
\end{dodo}

The \indcmdt{solve} works by minimising the squares of the residuals of all of the
equations supplied, and so even when no exact solution can be found, the best
compromise is returned. The following example has no solution -- a system of
three equations with two variables is over-constrained -- but PyXPlot
nonetheless finds a compromise solution:

\begin{verbatim}
pyxplot> solve x+y=10, x-y=3, 2*x+y=16 via x,y
pyxplot> print x
6.3571429
pyxplot> print y
3.4285714
\end{verbatim}

When complex arithmetic is enabled, the \indcmdt{solve} allows each of the
variables being fitted to take any value in the complex plane, and thus the
number of dimensions of the fitting problem is effectively doubled -- the real
and imaginary components of each variable are solved for separately -- as in
the following example:

\begin{verbatim}
pyxplot> set numerics complex
pyxplot> solve exp(x)=e*i via x
pyxplot> print Re(x)
1
pyxplot> print Im(x)/pi
0.5
\end{verbatim}

\section{Searching for Minima and Maxima of Functions}

The \indcmd{minimise}\indcmd{maximise} {\tt minimise} and {\tt maximise}
commands can be used to find the minima or maxima of algebraic expressions. In
each case, a single algebraic expression should be supplied for optimisation,
together with a comma-separated list of the variables which is should be
optimised with respect to. In the following example, a minimum of the
sinusoidal function $\cos(x)$ is sought:

\begin{verbatim}
pyxplot> set numerics real
pyxplot> x=0.1
pyxplot> minimise cos(x) via x
pyxplot> print x/pi
1
\end{verbatim}

\noindent Note that this particular example doesn't work when complex
arithmetic is enabled, since $\cos(x)$ diverges to $-\infty$ at $x=\pi+\infty
i$, and this is correctly identified by PyXPlot as the global minimum of the
function when complex numbers are allowed.

Various caveats apply both to the {\tt minimise} and {\tt maximise} commands,
as well as to the {\tt solve} command.  All of these commands operate by
searching numerically for optimal sets of input parameters to meet the criteria
set by the user. As with all numerical algorithms, there is no guarantee that
the {\it locally} optimum solutions returned are the {\it globally} optimum
solutions. It is always advisable to double-check that the answered returned
agree with common sense.

These commands can often find solutions to equations when these solutions are
either very large or very small, but they usually work best when the solution
they are looking for is roughly of order unity.  PyXPlot does have mechanisms
which attempt to correct cases where the supplied initial guess turns out to be
many orders of magnitude different from the true solution, but it cannot be
guaranteed not to wildly overshoot and produce unexpected results in such
cases.  To reiterate, it is always advisable to double-check that the answered
returned agree with common sense.

\example{ex:eqnsolve}{Finding the maximum of a blackbody curve}{
When a surface is heated to any given temperature $T$, it radiates thermally.
The amount of electromagnetic radiation emitted at any particular frequency,
per unit area of surface, per unit frequency of light, is given by the Planck
Law:
\begin{displaymath}
B_\nu(\nu,T)=\left(\frac{2h^3}{c^2}\right)\frac{\nu^3}{\exp(h\nu/kT)-1}
\end{displaymath}
The visible surface of the Sun has a temperature of approximately
$5800\,\mathrm{K}$ and radiates in such a fashion. In this example, we use the
{\tt solve}, {\tt minimise} and {\tt maximise} commands to locate the frequency
of light at which it emits the most energy per unit frequency interval.  This
task is simplified as PyXPlot has a system-defined mathematical function {\tt
Bv(nu,T)} which evaluates the expression given above.
\nlnp
Below, a plot is shown of the Planck Law for $T=5800\,\mathrm{K}$ to aid in
visualising the solution to this problem:
\nlscf
\begin{center}
\includegraphics[width=\textwidth]{examples/eps/ex_eqnsolve.eps}
\end{center}
\nlnp
To search for the maximum of this function using the \indcmdt{maximise}, we
must provide an initial guess to indicate that the answer sought should have
units of Hz:
\nlscf
\noindent {\tt pyxplot> nu = 1e14*unit(Hz)}\newline
\noindent {\tt pyxplot> maximise Bv(nu,5800*unit(K)) via nu}\newline
\noindent {\tt pyxplot> print nu}\newline
\noindent {\tt 340.9781 THz}
\nlnp
This maximum could also be sought be searching for turning points in the
function $B_\nu(\nu,T)$, i.e.\ by solving the equation
\begin{displaymath}
\frac{\mathrm{d}B_\nu(\nu,T)}{\mathrm{d}\nu}=0.
\end{displaymath}
This can be done as follows:
\nlscf
\noindent {\tt pyxplot> nu = 1e14*unit(Hz)}\newline
\noindent {\tt pyxplot> solve diff\_dnu(Bv(nu,5800*unit(K)))=0 via nu}\newline
\noindent {\tt pyxplot> print nu}\newline
\noindent {\tt YAY FOR PYXPLOT}
\nlnp
foo
}

\section{Working with Time-Series Data}
\label{sec:time_series}

\begin{verbatim}
set calendar british
x = time_juliandate(2000,1,1,0,0,0)
print time_diff(x, time_now())
print time_diff_string(x, time_now())

x = time_now()
print time_string(x)

set calendar julian

print time_string(x)
print time_string(time_now())

set calendar input russian output british
x = time_juliandate(1828,8,28,0,0,0)
print time_string(x)

set calendar islamic
print time_string(time_now())

set calendar hebrew
print time_string(time_now())
\end{verbatim}

\example{ex:timeseries}{An example}{
In this example,.
}

